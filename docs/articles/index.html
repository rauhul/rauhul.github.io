<!DOCTYPE html>
<html >
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    
    <title>Articles - rauhul.me</title>
    <meta name="description" content="">
    
    <meta property="og:url" content="http://localhost:3000/articles/">
    <meta property="og:title" content="Articles - rauhul.me">
    <meta property="og:description" content="">
    

    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="Articles - rauhul.me">
    <meta name="twitter:description" content="">
    

    <link rel="stylesheet" href="http://localhost:3000/css/reset.css">
    <link rel="stylesheet" href="http://localhost:3000/css/color.css">
    <link rel="stylesheet" href="http://localhost:3000/css/theme.css">

    <link rel="stylesheet" href="http://localhost:3000/css/header.css">
    <link rel="stylesheet" href="http://localhost:3000/css/content.css">
    <link rel="stylesheet" href="http://localhost:3000/css/footer.css">    

    <link rel="stylesheet" href="http://localhost:3000/css/photos.css">
    <link rel="stylesheet" href="http://localhost:3000/css/links.css">
    
</head>

<body>
    <div class="content">
        <div class="content-body">
            <div class="content-body-column-navigation">
                <header>
                    <nav>
                        <div class="navigation-secondary navigation-item">
                            <a href="/">rauhul</a>
                        </div>
                        <div class="navigation-spacer"></div>
                        <div class="navigation-primary navigation-item">
                            <a href="/about/">about</a>
                        </div>
        <div class="navigation-primary navigation-item">
                            <a href="/photos/">photos</a>
                        </div>
        <div class="navigation-primary navigation-item">
                            <a href="/articles/">articles</a>
                        </div>
        <div class="navigation-primary navigation-item">
                            <a href="/links/">links</a>
                        </div>
                        <div class="navigation-spacer"></div>
                    </nav>
                </header>
            </div>
            
            <div class="content-body-column-main">
                <main>
                    <h1>Articles</h1>
                    
                    
                    
                    
                    <div id="blog" class="wrapper">
                        
                        <div id="blog-articles" class="grid grid-321">
                            <h4>[&quot;next&quot;: [[&quot;contents&quot;: &quot;&lt;p&gt;I‚Äôm excited to share &lt;a href=\&quot;https://github.com/apple/swift-playdate-examples\&quot; target=\&quot;_blank\&quot;&gt;swift-playdate-examples&lt;/a&gt;, a technical demonstration of using Swift to build games for &lt;a href=\&quot;https://play.date/\&quot; target=\&quot;_blank\&quot;&gt;Playdate&lt;/a&gt;, a handheld game system by &lt;a href=\&quot;https://panic.com\&quot; target=\&quot;_blank\&quot;&gt;Panic&lt;/a&gt;.&lt;/p&gt;&lt;video title=\&quot;A screencapture of Swift Break running on Playdate hardware mirrored to a Mac.\&quot; autoplay loop muted style=\&quot;width: 100%; border-radius: 15px;\&quot;&gt;\n  &lt;source src=\&quot;{{site.url}}/assets/images/2024-03-12-byte-sized-swift-tiny-games-playdate/playdate-mirror-video-swiftbreak.mp4\&quot; type=\&quot;video/mp4\&quot;&gt;\n&lt;/video&gt;\n&lt;h2 id=\&quot;why-swift\&quot;&gt;Why Swift?&lt;/h2&gt;&lt;p&gt;Swift is widely known as the modern language for app development on Apple devices. However, over the course of its first decade, it has grown into a versatile, multi-platform language targeting use cases where you‚Äôd otherwise find C or C++.&lt;/p&gt;&lt;p&gt;Personally, I have come to appreciate Swift‚Äôs emphasis on memory safety and great ergonomics, and want these traits for embedded systems where reliability and security are critically important.&lt;/p&gt;&lt;p&gt;But embedded systems are not only found in mission-critical applications. Some are actually all fun and &lt;em&gt;games&lt;/em&gt;.&lt;/p&gt;&lt;h3 id=\&quot;playdate-by-panic\&quot;&gt;Playdate by Panic&lt;/h3&gt;&lt;p&gt;Over the holiday season, I read about building Playdate games in C and became curious if the same was possible in Swift. For those unfamiliar with Playdate, it is a tiny handheld game system built by Panic, creators of popular apps and games like ‚ÄúTransmit,‚Äù ‚ÄúNova,‚Äù ‚ÄúFirewatch,‚Äù ‚ÄúUntitled Goose Game,‚Äù and more. It houses a Cortex M7 processor, a 400 by 240 1-bit display, and has a small runtime for hosting games. Additionally, Panic provides an &lt;a href=\&quot;https://play.date/dev/\&quot; target=\&quot;_blank\&quot;&gt;SDK&lt;/a&gt; for building games in both C and Lua.&lt;/p&gt;&lt;p&gt;While most Playdate games are written in Lua for ease of development, they can run into performance problems that necessitate the added complexity of using C. Swift‚Äôs combination of high-level ergonomics with low-level performance, as well as its strong support for interoperating with C, make it seem like a good match for the Playdate. However, the typical Swift application and runtime exceed the device‚Äôs tight resource constraints.&lt;/p&gt;&lt;p&gt;Regardless, I still wanted to create a game in Swift and I had a good idea for the approach.&lt;/p&gt;&lt;h3 id=\&quot;the-embedded-language-mode\&quot;&gt;The Embedded Language Mode&lt;/h3&gt;&lt;p&gt;Recently, the Swift project began developing a new embedded language mode to support highly constrained platforms. This mode utilizes generic specialization, inlining, and dead code stripping to produce tiny binaries, while retaining the core features of Swift.&lt;/p&gt;&lt;blockquote class=\&quot;note\&quot;&gt;&lt;p&gt;Note: The embedded language mode is actively evolving and is helping drive the development of language features such as: &lt;a href=\&quot;https://github.com/swiftlang/swift-evolution/blob/main/proposals/0390-noncopyable-structs-and-enums.md\&quot; target=\&quot;_blank\&quot;&gt;non-copyable types&lt;/a&gt;, &lt;a href=\&quot;https://github.com/swiftlang/swift-evolution/blob/main/proposals/0413-typed-throws.md\&quot; target=\&quot;_blank\&quot;&gt;typed throws&lt;/a&gt;, etc. It is available now in &lt;a href=\&quot;https://www.swift.org/download/\&quot; target=\&quot;_blank\&quot;&gt;nightly toolchains&lt;/a&gt; and if you‚Äôre curious to learn more, check out the &lt;a href=\&quot;https://github.com/swiftlang/swift-evolution/blob/main/visions/embedded-swift.md\&quot; target=\&quot;_blank\&quot;&gt;Vision for Embedded Swift&lt;/a&gt;.&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;These defining characteristics make the embedded language mode a great solution for shrinking Swift to fit the Playdate‚Äôs constraints.&lt;/p&gt;&lt;p&gt;With the embedded Swift language mode in hand, I got to work.&lt;/p&gt;&lt;h2 id=\&quot;the-games\&quot;&gt;The Games&lt;/h2&gt;&lt;p&gt;I wrote two small games in Swift for the Playdate. The first game is a port of the Playdate SDK sample of &lt;a href=\&quot;https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life\&quot; target=\&quot;_blank\&quot;&gt;Conway‚Äôs Game of Life&lt;/a&gt; into Swift:&lt;/p&gt;&lt;p&gt;    &lt;img src=\&quot;/assets/images/2024-03-12-byte-sized-swift-tiny-games-playdate/playdate-simulator-still-life.png\&quot; alt=\&quot;A screenshot of the Playdate Simulator running Conway‚Äôs Game of Life.\&quot;&gt;&lt;/p&gt;&lt;p&gt;This game is one Swift file that builds directly against the Playdate C API and does not require dynamic memory allocation. The packaged game clocks in at 788 bytes, slightly smaller than the C example, which is 904 bytes.&lt;/p&gt;&lt;pre&gt;&lt;code class=\&quot;language-shell\&quot;&gt;$ wc -c &amp;lt; $REPO_ROOT/Examples/Life/Life.pdx/pdex.bin\n     788\n\n$ wc -c &amp;lt; $HOME/Developer/PlaydateSDK/C_API/Examples/GameOfLife.pdx/pdex.bin\n     904\n&lt;/code&gt;&lt;/pre&gt;&lt;blockquote class=\&quot;note\&quot;&gt;&lt;p&gt;Note: Both versions could likely be made smaller, but I did not try to optimize code size.&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;The second game is a paddle-and-ball style game named ‚ÄúSwift Break.‚Äù&lt;/p&gt;&lt;p&gt;    &lt;img src=\&quot;/assets/images/2024-03-12-byte-sized-swift-tiny-games-playdate/playdate-simulator-still-swiftbreak.png\&quot; alt=\&quot;A screenshot of the Playdate Simulator with the Swift Break splash screen.\&quot;&gt;&lt;/p&gt;&lt;p&gt;Swift Break uses the same high-level language features you‚Äôd find in desktop and server applications, such as &lt;a href=\&quot;https://docs.swift.org/swift-book/documentation/the-swift-programming-language/enumerations/#Associated-Values\&quot; target=\&quot;_blank\&quot;&gt;enums with associated values&lt;/a&gt;, &lt;a href=\&quot;https://docs.swift.org/swift-book/documentation/the-swift-programming-language/generics\&quot; target=\&quot;_blank\&quot;&gt;generic types and functions&lt;/a&gt;, and &lt;a href=\&quot;https://docs.swift.org/swift-book/documentation/the-swift-programming-language/memorysafety\&quot; target=\&quot;_blank\&quot;&gt;automatic memory management&lt;/a&gt; to simplify game development while retaining C-level performance.&lt;/p&gt;&lt;p&gt;For example, here‚Äôs the core game logic for handling ball bounces:&lt;/p&gt;&lt;pre&gt;&lt;code class=\&quot;language-swift\&quot;&gt;sprite.moveWithCollisions(goalX: newX, goalY: newY) { _, _, collisions in\n  for collision in collisions {\n    let otherSprite = Sprite(borrowing: collision.other)\n\n    // If we hit a visible brick, remove it.\n    if otherSprite.tag == .brick, otherSprite.isVisible {\n      otherSprite.removeSprite()\n      activeGame.bricksRemaining -= 1\n    }\n\n    var normal = Vector(collision.normal)\n\n    if otherSprite.tag == .paddle {\n      // Compute deflection angle (radians) for the normal in domain\n      // -pi/6 to pi/6.\n      let placement = placement(of: collision, along: otherSprite)\n      let deflectionAngle = placement * (.pi / 6)\n      normal.rotate(by: deflectionAngle)\n    }\n\n    activeGame.ballVelocity.reflect(along: normal)\n  }\n}\n&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;It calls a &lt;code&gt;moveWithCollisions&lt;/code&gt; method to move the ball, iterating through a collection of objects the ball bounced off of while moving.&lt;/p&gt;&lt;p&gt;Swift Break features a splash screen, a pause menu, paddle-location-based bounce physics, infinite levels, a game over screen, and allows you to control the paddle with either the D-Pad or the Crank!&lt;/p&gt;&lt;h2 id=\&quot;try-it-out\&quot;&gt;Try it Out&lt;/h2&gt;&lt;p&gt;If you‚Äôre eager to use Swift on your Playdate, the &lt;a href=\&quot;https://github.com/apple/swift-playdate-examples\&quot; target=\&quot;_blank\&quot;&gt;swift-playdate-examples&lt;/a&gt; repository has you covered. It contains the above ready-to-use examples that demonstrate how to build Swift games for the Playdate, both for the simulator and the hardware.&lt;/p&gt;&lt;p&gt;Additionally, the repository includes detailed documentation to guide you through the setup process. Whether you‚Äôre a seasoned developer or just starting, you‚Äôll find the necessary resources to bring your ideas to life.&lt;/p&gt;&lt;p&gt;But if you‚Äôre up for a deep dive into the technical details of what it takes to bring Swift to a new platform, read on!&lt;/p&gt;&lt;h2 id=\&quot;deep-dive-bringing-swift-to-the-playdate\&quot;&gt;Deep Dive: Bringing Swift to the Playdate&lt;/h2&gt;&lt;p&gt;Bringing up a new platform is always fraught with challenges and infuriating bugs. Everything is broken with numerous false starts, until you clear the last bug, and then it all comes together. Getting Swift games running on the Playdate was no different.&lt;/p&gt;&lt;p&gt;My general approach was to leverage Swift‚Äôs interoperability to build on top of the Playdate C SDK. The good news is that the Swift toolchain already had all the features I needed to get this working. I just had to figure out how to put them together. Here‚Äôs an overview of the path I took:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Building object files for the Playdate Simulator&lt;/li&gt;&lt;li&gt;Importing the Playdate C API&lt;/li&gt;&lt;li&gt;Running on the Simulator&lt;/li&gt;&lt;li&gt;Running on the Hardware&lt;/li&gt;&lt;li&gt;Improving the API with Swift&lt;/li&gt;&lt;li&gt;Completing Swift Break&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;Without further ado, let‚Äôs get started.&lt;/p&gt;&lt;h3 id=\&quot;building-object-files-for-the-playdate-simulator\&quot;&gt;Building object files for the Playdate Simulator&lt;/h3&gt;&lt;blockquote class=\&quot;note\&quot;&gt;&lt;p&gt;Note: The commands mentioned below were run with a Swift nightly toolchain installed and have the &lt;code&gt;TOOLCHAINS&lt;/code&gt; environment variable set to the name of the toolchain.&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;My first step was compiling an object file for the Playdate Simulator. The simulator works by dynamically loading host libraries, so I needed to build the object files for the host‚Äôs platform and architecture (the so-called &lt;em&gt;triple&lt;/em&gt; in compiler-speak), which &lt;code&gt;swiftc&lt;/code&gt; does by default. The only additional flags I needed were for enabling embedded Swift and code optimizations.&lt;/p&gt;&lt;pre&gt;&lt;code class=\&quot;language-shell\&quot;&gt;$ cat test.swift\nlet value = 1\n\n$ mkdir build\n\n$ swiftc -c test.swift -o build/test.o \\\n    -Osize -wmo -enable-experimental-feature Embedded\n\n$ file build/test.o\ntest.o: Mach-O 64-bit object arm64\n&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=\&quot;importing-the-playdate-c-api\&quot;&gt;Importing the Playdate C API&lt;/h3&gt;&lt;p&gt;The next step was compiling against the Playdate C API from Swift. This was straightforward due to the structure of the Playdate C header files and Swift‚Äôs native support for interoperating with C.&lt;/p&gt;&lt;p&gt;I started by locating the Playdate C header files:&lt;/p&gt;&lt;pre&gt;&lt;code class=\&quot;language-shell\&quot;&gt;$ ls $HOME/Developer/PlaydateSDK/C_API/\nExamples     buildsupport pd_api       pd_api.h\n\n$ ls $HOME/Developer/PlaydateSDK/C_API/pd_api\npd_api_display.h     pd_api_gfx.h         pd_api_lua.h         pd_api_sound.h       pd_api_sys.h\npd_api_file.h        pd_api_json.h        pd_api_scoreboards.h pd_api_sprite.h\n&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;And used an ‚Äúinclude search path‚Äù (&lt;code&gt;-I&lt;/code&gt;) to tell the Swift compiler‚Äôs C interoperability feature where to find them. I additionally needed to pass a ‚Äúdefine‚Äù (&lt;code&gt;-D&lt;/code&gt;) to tell the compiler how to parse the header files:&lt;/p&gt;&lt;pre&gt;&lt;code class=\&quot;language-shell\&quot;&gt;$ swiftc ... -Xcc -I -Xcc $HOME/Developer/PlaydateSDK/C_API/ -Xcc -DTARGET_EXTENSION\n&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Next, I created a &lt;a href=\&quot;https://clang.llvm.org/docs/Modules.html#module-maps\&quot; target=\&quot;_blank\&quot;&gt;module map file&lt;/a&gt; to wrap the headers into an importable module from Swift:&lt;/p&gt;&lt;pre&gt;&lt;code class=\&quot;language-shell\&quot;&gt;$ cat $HOME/Developer/PlaydateSDK/C_API/module.modulemap\nmodule CPlaydate [system] {\n  umbrella header \&quot;pd_api.h\&quot;\n  export *\n}\n&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;And used an ‚Äúimport search path‚Äù (&lt;code&gt;-I&lt;/code&gt;) to tell the Swift compiler where to find the CPlaydate module:&lt;/p&gt;&lt;pre&gt;&lt;code class=\&quot;language-shell\&quot;&gt;$ swiftc ... -I $HOME/Developer/PlaydateSDK/C_API/\n&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Lastly, I made a minimal ‚Äúlibrary‚Äù using the Playdate C API from Swift and compiled using the flags above:&lt;/p&gt;&lt;pre&gt;&lt;code class=\&quot;language-shell\&quot;&gt;$ cat test.swift\nimport CPlaydate\nlet pd: UnsafePointer&amp;lt;PlaydateAPI&amp;gt;? = nil\n\n$ mkdir build\n\n$ swiftc \\\n    -c test.swift \\\n    -o build/test.o \\\n    -Osize -wmo -enable-experimental-feature Embedded \\\n    -Xcc -I -Xcc $HOME/Developer/PlaydateSDK/C_API/ \\\n    -Xcc -DTARGET_EXTENSION \\\n    -I $HOME/Developer/PlaydateSDK/C_API/\n\n$ file build/test.o\ntest.o: Mach-O 64-bit object arm64\n&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=\&quot;running-on-the-simulator\&quot;&gt;Running on the Simulator&lt;/h3&gt;&lt;p&gt;Once I was able to use the Playdate C API from Swift, I ported the Conway‚Äôs Game of Life example included in the Playdate SDK to Swift, referencing &lt;a href=\&quot;https://sdk.play.date/2.2.0/Inside%20Playdate%20with%20C.html\&quot; target=\&quot;_blank\&quot;&gt;Inside Playdate with C&lt;/a&gt; frequently to familiarize myself with the API.&lt;/p&gt;&lt;p&gt;The C implementation of Conway‚Äôs strictly operates on Playdate OS-vended frame buffers and uses the display as game state, removing the need for separate data structures and dynamic allocations. As a result, the porting process was very mechanical because the bit manipulation and pointer operations in the C example have direct Swift analogs:&lt;/p&gt;&lt;pre&gt;&lt;code class=\&quot;language-c\&quot;&gt;static inline int val(uint8_t* row, int x) {\n    return 1 - ((row[x/8] &amp;gt;&amp;gt; (7 - (x%8))) &amp; 1);\n}\n\nstatic inline int ison(uint8_t* row, int x) {\n    return !(row[x/8] &amp; (0x80 &amp;gt;&amp;gt; (x%8)));\n}\n&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code class=\&quot;language-swift\&quot;&gt;struct Row {\n  var buffer: UnsafeMutablePointer&amp;lt;UInt8&amp;gt;\n\n  func value(at column: Int32) -&amp;gt; UInt8 {\n    isOn(at: column) ? 1 : 0\n  }\n\n  func isOn(at column: Int32) -&amp;gt; Bool {\n    let byte = buffer[Int(column / 8)]\n    let bitPosition = 0x80 &amp;gt;&amp;gt; (column % 8)\n    return (byte &amp; bitPosition) == 0\n  }\n}\n&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;I built the source into a dynamic library and used &lt;code&gt;pdc&lt;/code&gt; (the Playdate compiler) to wrap the final &lt;code&gt;dylib&lt;/code&gt; into a &lt;code&gt;pdx&lt;/code&gt; (Playdate executable).&lt;/p&gt;&lt;pre&gt;&lt;code class=\&quot;language-shell\&quot;&gt;$ swiftc \\\n    -emit-library test.swift \\\n    -o build/pdex.dylib \\\n    ...\n\n$ file build/pdex.dylib\npdex.dylib: Mach-O 64-bit dynamically linked shared library arm64\n\n$ $HOME/Developer/PlaydateSDK/bin/pdc build Test\n\n$ ls Test.pdx\npdex.dylib pdxinfo\n&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;I opened my game file &lt;code&gt;Test.pdx&lt;/code&gt; using the Playdate simulator and as you might expect, it worked on the first try ‚Ä¶ just kidding, it crashed!&lt;/p&gt;&lt;p&gt;After some debugging, I realized the &lt;code&gt;Makefile&lt;/code&gt; used to compile the C example included an additional file &lt;code&gt;setup.c&lt;/code&gt; from the SDK containing the symbol &lt;code&gt;_eventHandlerShim&lt;/code&gt; needed to bootstrap the game. If this symbol is not present in the binary, the Simulator falls back to bootstrapping the game using the symbol &lt;code&gt;_eventHandler&lt;/code&gt; which my binary did contain, but meant my game skipped an important setup step.&lt;/p&gt;&lt;p&gt;So, I compiled &lt;code&gt;setup.c&lt;/code&gt; into an object file using &lt;code&gt;clang&lt;/code&gt;, linked it into my dynamic library, re-ran, and voila! I had Conway‚Äôs Game of Life written in Swift running on the Playdate Simulator.&lt;/p&gt;&lt;h3 id=\&quot;running-on-the-hardware\&quot;&gt;Running on the Hardware&lt;/h3&gt;&lt;p&gt;After successfully running on the simulator, I wanted to run the game on real hardware. A colleague graciously allowed me to borrow their Playdate and I began hacking away.&lt;/p&gt;&lt;p&gt;I started by matching the triple used by the C examples for the device and seeing what happened.&lt;/p&gt;&lt;pre&gt;&lt;code class=\&quot;language-shell\&quot;&gt;$ swiftc ... -target armv7em-none-none-eabi\n&amp;lt;module-includes&amp;gt;:1:10: note: in file included from &amp;lt;module-includes&amp;gt;:1:\n#include \&quot;pd_api.h\&quot;\n         ^\n$HOME/Developer/PlaydateSDK/C_API/pd_api.h:13:10: error: \&#39;stdlib.h\&#39; file not found\n#include &amp;lt;stdlib.h&amp;gt;\n         ^\n&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;These errors did not previously occur because I was targeting the host machine and used the host headers for the C standard library. I considered using the same host headers for the target device, but didn‚Äôt want to debug platform incompatibilities. Little did I know, I would have to do this regardless.&lt;/p&gt;&lt;p&gt;Instead, I decided to follow the route used by the C example programs which leverage the libc headers from a &lt;code&gt;gcc&lt;/code&gt; toolchain installed with the Playdate SDK. I copied the include paths used by the C examples and re-ran the compile.&lt;/p&gt;&lt;pre&gt;&lt;code class=\&quot;language-shell\&quot;&gt;$ mkdir build\n\n$ GCC_LIB=/usr/local/playdate/gcc-arm-none-eabi-9-2019-q4-major/lib\n\n$ swiftc \\\n    -c test.swift \\\n    -o build/test.o \\\n    -target armv7em-none-none-eabi \\\n    -Osize -wmo -enable-experimental-feature Embedded \\\n    -I $HOME/Developer/PlaydateSDK/C_API/ \\\n    -Xcc -DTARGET_EXTENSION \\\n    -Xcc -I -Xcc $HOME/Developer/PlaydateSDK/C_API/ \\\n    -Xcc -I -Xcc $GCC_LIB/gcc/arm-none-eabi/9.2.1/include \\\n    -Xcc -I -Xcc $GCC_LIB/gcc/arm-none-eabi/9.2.1/include-fixed \\\n    -Xcc -I -Xcc $GCC_LIB/gcc/arm-none-eabi/9.2.1/../../../../arm-none-eabi/include\n\n$ file build/test.o\ntest.o: ELF 32-bit LSB relocatable, ARM, EABI5 version 1 (SYSV), not stripped\n&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The compile succeeded and I had an object file for the real hardware. I went through similar steps to link and package the object file into a &lt;code&gt;pdx&lt;/code&gt;, using &lt;code&gt;clang&lt;/code&gt; as the linker driver.&lt;/p&gt;&lt;p&gt;I deployed the game onto a Playdate, and ‚Ä¶ it crashed.&lt;/p&gt;&lt;p&gt;For some reason, when the frame-update function pointer was called, the game would crash! Debugging this issue was confusing at first, but due to past experience deploying Swift onto a Cortex M7, I realized I likely had a calling convention mismatch. I added a compiler flag &lt;code&gt;-Xfrontend -experimental-platform-c-calling-convention=arm_aapcs_vfp&lt;/code&gt; to try to match the calling convention used by the Playdate OS.&lt;/p&gt;&lt;p&gt;Once again, I deployed my game to the Playdate and ‚Ä¶ it actually worked! You can see the game in action below:&lt;/p&gt;&lt;video title=\&quot;A video of Conway\&#39;s Game of Life running on Playdate hardware mirrored to a Mac.\&quot; autoplay loop muted style=\&quot;width: 100%; border-radius: 15px;\&quot;&gt;\n  &lt;source src=\&quot;{{site.url}}/assets/images/2024-03-12-byte-sized-swift-tiny-games-playdate/playdate-mirror-video-life.mp4\&quot; type=\&quot;video/mp4\&quot;&gt;\n&lt;/video&gt;\n&lt;p&gt;I then integrated my manual compilation steps into the Makefiles found in the Playdate SDK, going through a number of options before landing on the final solution found in &lt;code&gt;swift-playdate-examples&lt;/code&gt;. The result of this effort was a single &lt;code&gt;make&lt;/code&gt; command to build a &lt;code&gt;pdx&lt;/code&gt; compatible with both the simulator and hardware!&lt;/p&gt;&lt;h3 id=\&quot;improving-the-api-with-swift\&quot;&gt;Improving the API with Swift&lt;/h3&gt;&lt;p&gt;After porting Conway‚Äôs Game of Life, I began a more ambitious project: a paddle-and-ball style game named Swift Break. However, I quickly encountered friction using the raw Playdate C API directly in Swift. In typical programming fashion, I took a detour to work on the API‚Äôs ergonomics instead of the game! At this point, I had also piqued the interest of some colleagues who contributed further improvements.&lt;/p&gt;&lt;p&gt;One hurdle was the naming conventions of the imported API. In C, enum cases are often prefixed with their type‚Äôs name to prevent programmers from inadvertently mixing unrelated enum instances and case constants. However, in Swift, such prefixes are unnecessary as the compiler type-checks comparisons to ensure the correct cases are used.&lt;/p&gt;&lt;p&gt;Fortunately, Swift already provides tools for addressing this precise issue, known as &lt;a href=\&quot;https://clang.llvm.org/docs/APINotes.html\&quot; target=\&quot;_blank\&quot;&gt;API notes&lt;/a&gt;. I added an API notes file to the Playdate SDK and renamed enum cases with more idiomatic Swift names:&lt;/p&gt;&lt;pre&gt;&lt;code class=\&quot;language-swift\&quot;&gt;// Before\nif event == kEventPause { ... }\n\n// After\nif event == .pause { ... }\n&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;A bigger issue, however, was the lack of nullability annotations in the C API. This meant the generated code had redundant null checks everywhere, bloating code size and hurting performance. While I usually would have used API notes to add the missing annotations, this was not possible. The C API uses structs with function pointers as a ‚Äúvtable‚Äù, and unfortunately, these are not currently modifiable with API notes. Due to this incompatibility, I had to adopt a suboptimal solution: pervasively using &lt;code&gt;Optional.unsafelyUnwrapped&lt;/code&gt; throughout the Swift code.&lt;/p&gt;&lt;p&gt;Although this approach eliminated the null checks, it dramatically hurt readability:&lt;/p&gt;&lt;pre&gt;&lt;code class=\&quot;language-swift\&quot;&gt;// C API in Swift with redundant null checks\nlet spritePointer = playdate_api.pointee.sprite.pointee.newSprite()\n\n// C API in Swift without redundant null checks\nlet spritePointer = playdate_api.unsafelyUnwrapped.pointee.sprite.unsafelyUnwrapped.pointee.newSprite.unsafelyUnwrapped()\n&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;To address the readability issues, I created a thin Swift overlay on top of the C API. I wrapped function pointer accesses into static and instance methods on Swift types and converted function get/set pairs to Swift properties. Creating a sprite became much more intuitive and introduced zero overhead on top of the equivalent imported C calls.&lt;/p&gt;&lt;pre&gt;&lt;code class=\&quot;language-swift\&quot;&gt;var sprite = Sprite(bitmapPath: \&quot;background.png\&quot;)\nsprite.collisionsEnabled = false\nsprite.zIndex = 0\nsprite.addSprite()\n&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Colleagues further improved the overlay by abstracting Playdate APIs requiring manual memory management to be automatically handled. An excellent example is the C API‚Äôs &lt;a href=\&quot;https://sdk.play.date/2.2.0/Inside%20Playdate%20with%20C.html#f-sprite.moveWithCollisions\&quot; target=\&quot;_blank\&quot;&gt;&lt;code&gt;moveWithCollisions&lt;/code&gt;&lt;/a&gt; function, which returns a buffer of &lt;code&gt;SpriteCollisionInfo&lt;/code&gt; structs that must be freed by the caller. Using the overlay allowed us to avoid manually deallocating the buffer and made the API easier to use:&lt;/p&gt;&lt;pre&gt;&lt;code class=\&quot;language-swift\&quot;&gt;// moveWithCollisions without the overlay\nvar count: Int32 = 0\nvar actualX: Int32 = 0\nvar actualY: Int32 = 0\nlet collisionsStartAddress = playdate_api.pointee.sprite.pointee.moveWithCollisions(sprite, 10, 10, &amp;actualX, &amp;actualY, &amp;count)\nlet collisions = UnsafeBufferPointer(start: collisionsStartAddress, count: count)\ndefer { collisions.deallocate() }\nfor collision in collisions { ... }\n\n// moveWithCollisions with the overlay\nsprite.moveWithCollisions(goalX: 10, goalY: 10) { actualX, actualY, collisions in\n    for collision in collisions { ... }\n}\n&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;These improvements dramatically streamlined writing code for the Playdate. Additionally, as Swift‚Äôs support for ownership and non-copyable types improves, I anticipate even more ergonomic representations of the C APIs without language overhead.&lt;/p&gt;&lt;h3 id=\&quot;completing-swift-break\&quot;&gt;Completing Swift Break&lt;/h3&gt;&lt;p&gt;Equipped with a refined Swift Playdate API, I returned to developing Swift Break.&lt;/p&gt;&lt;p&gt;I nailed down the basics pretty quickly, but couldn‚Äôt resist adding extra features just for the fun of it. One of the highlights was implementing basic logic to deflect ball bounces based on the location where the ball and paddle collide.&lt;/p&gt;&lt;p&gt;This feature required calculating a normal vector relative to a hypothetical curve representing a rounded paddle and then reflecting the ball‚Äôs velocity about the normal. Here‚Äôs a visualization of the intended behavior:&lt;/p&gt;&lt;video title=\&quot;A Desmos geometric animation of Swift Break ball bouncing logic.\&quot; autoplay loop muted style=\&quot;width: 100%; border-radius: 15px;\&quot;&gt;\n  &lt;source src=\&quot;{{site.url}}/assets/images/2024-03-12-byte-sized-swift-tiny-games-playdate/desmos-ball-bounce.mp4\&quot; type=\&quot;video/mp4\&quot;&gt;\n&lt;/video&gt;\n&lt;blockquote class=\&quot;note\&quot;&gt;&lt;p&gt;Note: Making the animation for this post ironically helped me root cause a bug in the bouncing logic. Under some combinations of entry angle and normal angle, the current design can cause the ball to bounce &lt;em&gt;down&lt;/em&gt; into the paddle instead of up.&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;To turn the math into an algorithm, I had to perform the following steps:&lt;/p&gt;&lt;ol&gt;&lt;li&gt;Check if the object the ball collided with is the paddle&lt;/li&gt;&lt;li&gt;Compute the location of the collision along the paddle from -1 to +1&lt;/li&gt;&lt;li&gt;Map the location into a deflection angle from from -œÄ/6 to +œÄ/6&lt;/li&gt;&lt;li&gt;Rotate the collision normal vector by the deflection angle&lt;/li&gt;&lt;li&gt;Reflect the ball‚Äôs velocity along the rotated normal&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;I then directly translated this algorithm into code inside the ball collision callback:&lt;/p&gt;&lt;pre&gt;&lt;code class=\&quot;language-swift\&quot;&gt;if otherSprite.tag == .paddle {                                // 1\n  let placement = placement(of: collision, along: otherSprite) // 2\n  let deflectionAngle = placement * (.pi / 6)                  // 3\n  normal.rotate(by: deflectionAngle)                           // 4\n}\nballVelocity.reflect(along: normal)                            // 5\n&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=\&quot;running-on-the-hardware-again\&quot;&gt;Running on the Hardware (Again!)&lt;/h3&gt;&lt;p&gt;Throughout the development of ‚ÄúSwift Break,‚Äù I regularly deployed the game to the Playdate Simulator. However, the real challenge emerged when I decided to run the game on actual Playdate hardware. As usual, I loaded the game, and ‚Ä¶ yet again, it crashed, but this time a lot of things were going wrong.&lt;/p&gt;&lt;p&gt;To cut a long debugging story short, I found that the &lt;code&gt;-Xfrontend&lt;/code&gt; flag mentioned earlier did not entirely resolve the calling convention issues. To address this, I needed to configure the compiler to match the CPU and floating-point ABI of the microcontroller in the Playdate. This aspect was overlooked when I was porting Conway‚Äôs Game of Life since I happened to both not pass structs by value and didn‚Äôt use floating-point operations.&lt;/p&gt;&lt;p&gt;The final and most confusing crash arose from a specific Playdate C API call returning an enum from the Playdate OS. After a thorough debugging process, e.g. using &lt;code&gt;printf&lt;/code&gt; everywhere, I uncovered a discrepancy in the memory layout of the enum between the system built with &lt;code&gt;gcc&lt;/code&gt; and the game built with &lt;code&gt;swiftc&lt;/code&gt;. With further research I found the difference stemmed from &lt;code&gt;gcc&lt;/code&gt; defaulting to &lt;code&gt;-fshort-enums&lt;/code&gt; while &lt;code&gt;swiftc&lt;/code&gt; via &lt;code&gt;clang&lt;/code&gt; used &lt;code&gt;-fno-short-enums&lt;/code&gt; for the &lt;code&gt;armv7em-none-none-eabi&lt;/code&gt; triple.&lt;/p&gt;&lt;p&gt;I collected these new and removed flags into the following compile command:&lt;/p&gt;&lt;pre&gt;&lt;code class=\&quot;language-shell\&quot;&gt;$ swiftc \\\n    -c test.swift \\\n    -o build/test.o \\\n    -target armv7em-none-none-eabi \\\n    -Osize -wmo -enable-experimental-feature Embedded \\\n    -I $HOME/Developer/PlaydateSDK/C_API \\\n    -Xcc -D__FPU_USED=1 \\\n    -Xcc -DTARGET_EXTENSION \\\n    -Xcc -falign-functions=16 \\\n    -Xcc -fshort-enums \\\n    -Xcc -mcpu=cortex-m7 \\\n    -Xcc -mfloat-abi=hard \\\n    -Xcc -mfpu=fpv5-sp-d16 \\\n    -Xcc -mthumb \\\n    -Xcc -I -Xcc $HOME/Developer/PlaydateSDK/C_API/ \\\n    -Xcc -I -Xcc $GCC_LIB/gcc/arm-none-eabi/9.2.1/include \\\n    -Xcc -I -Xcc $GCC_LIB/gcc/arm-none-eabi/9.2.1/include-fixed \\\n    -Xcc -I -Xcc $GCC_LIB/gcc/arm-none-eabi/9.2.1/../../../../arm-none-eabi/include \\\n    -Xfrontend -disable-stack-protector \\\n    -Xfrontend -experimental-platform-c-calling-convention=arm_aapcs_vfp \\\n    -Xfrontend -function-sections\n&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;With these adjustments, I attempted once more, and &lt;em&gt;finally&lt;/em&gt; ‚ÄúSwift Break‚Äù successfully ran on the Playdate hardware! I‚Äôve included a brief video showcasing the game below:&lt;/p&gt;&lt;video title=\&quot;A screencapture of Swift Break running on Playdate hardware mirrored to a Mac.\&quot; autoplay loop muted style=\&quot;width: 100%; border-radius: 15px;\&quot;&gt;\n  &lt;source src=\&quot;{{site.url}}/assets/images/2024-03-12-byte-sized-swift-tiny-games-playdate/playdate-mirror-video-swiftbreak.mp4\&quot; type=\&quot;video/mp4\&quot;&gt;\n&lt;/video&gt;\n&lt;h2 id=\&quot;wrapping-up\&quot;&gt;Wrapping Up&lt;/h2&gt;&lt;p&gt;Thanks for diving into the bring-up journey with me. From refining the Swift Playdate API to tackling issues involving calling conventions, CPU configurations, and memory layout disparities, there was no shortage of challenges.&lt;/p&gt;&lt;p&gt;However, with the issues now resolved, creating Playdate games in Swift is a streamlined process. Just run &lt;code&gt;make&lt;/code&gt; and enjoy a development experience with Swift that is both expressive &lt;em&gt;and&lt;/em&gt; performant.&lt;/p&gt;&lt;p&gt;You can find all the code examples mentioned in this post in the &lt;a href=\&quot;https://github.com/apple/swift-playdate-examples\&quot; target=\&quot;_blank\&quot;&gt;swift-playdate-examples&lt;/a&gt; repository with accompanying ‚ÄúGetting Started‚Äù documentation.&lt;/p&gt;&lt;p&gt;I hope this post encourages you to explore the possibilities of using Swift in unconventional environments. Feel free to reach out with your experiences, questions, or game ideas on the &lt;a href=\&quot;https://forums.swift.org/t/byte-sized-swift-building-tiny-games-for-the-playdate/70615\&quot; target=\&quot;_blank\&quot;&gt;Swift Forums&lt;/a&gt;!&lt;/p&gt;&lt;p&gt;Happy coding! üéÆ&lt;/p&gt;&quot;, &quot;canonical&quot;: &quot;http://localhost:3000/articles/2024-03-12-byte-sized-swift-tiny-games-playdate/&quot;, &quot;permalink&quot;: &quot;http://localhost:3000/articles/2024-03-12-byte-sized-swift-tiny-games-playdate/&quot;, &quot;slug&quot;: &quot;articles/2024-03-12-byte-sized-swift-tiny-games-playdate&quot;, &quot;lastModification&quot;: ToucanSDK.PageBundle.DateValue(html: &quot;March 08, 2025&quot;, rss: &quot;Sat, 08 Mar 2025 19:53:28 +0000&quot;, sitemap: &quot;2025-03-08&quot;), &quot;description&quot;: &quot;FIXME: Write this..&quot;, &quot;title&quot;: &quot;Byte-sized Swift: Building Tiny Games for the Playdate&quot;, &quot;css&quot;: [], &quot;imageUrl&quot;: false, &quot;toc&quot;: [ToucanSDK.ToCNode(level: 2, text: &quot;Why Swift?&quot;, fragment: &quot;why-swift&quot;, children: [ToucanSDK.ToCNode(level: 3, text: &quot;Playdate by Panic&quot;, fragment: &quot;playdate-by-panic&quot;, children: []), ToucanSDK.ToCNode(level: 3, text: &quot;The Embedded Language Mode&quot;, fragment: &quot;the-embedded-language-mode&quot;, children: [])]), ToucanSDK.ToCNode(level: 2, text: &quot;The Games&quot;, fragment: &quot;the-games&quot;, children: []), ToucanSDK.ToCNode(level: 2, text: &quot;Try it Out&quot;, fragment: &quot;try-it-out&quot;, children: []), ToucanSDK.ToCNode(level: 2, text: &quot;Deep Dive: Bringing Swift to the Playdate&quot;, fragment: &quot;deep-dive-bringing-swift-to-the-playdate&quot;, children: [ToucanSDK.ToCNode(level: 3, text: &quot;Building object files for the Playdate Simulator&quot;, fragment: &quot;building-object-files-for-the-playdate-simulator&quot;, children: []), ToucanSDK.ToCNode(level: 3, text: &quot;Importing the Playdate C API&quot;, fragment: &quot;importing-the-playdate-c-api&quot;, children: []), ToucanSDK.ToCNode(level: 3, text: &quot;Running on the Simulator&quot;, fragment: &quot;running-on-the-simulator&quot;, children: []), ToucanSDK.ToCNode(level: 3, text: &quot;Running on the Hardware&quot;, fragment: &quot;running-on-the-hardware&quot;, children: []), ToucanSDK.ToCNode(level: 3, text: &quot;Improving the API with Swift&quot;, fragment: &quot;improving-the-api-with-swift&quot;, children: []), ToucanSDK.ToCNode(level: 3, text: &quot;Completing Swift Break&quot;, fragment: &quot;completing-swift-break&quot;, children: []), ToucanSDK.ToCNode(level: 3, text: &quot;Running on the Hardware (Again!)&quot;, fragment: &quot;running-on-the-hardware-again&quot;, children: [])]), ToucanSDK.ToCNode(level: 2, text: &quot;Wrapping Up&quot;, fragment: &quot;wrapping-up&quot;, children: [])], &quot;js&quot;: [], &quot;publication&quot;: ToucanSDK.PageBundle.DateValue(html: &quot;March 12, 2024&quot;, rss: &quot;Tue, 12 Mar 2024 10:00:00 +0000&quot;, sitemap: &quot;2024-03-12&quot;), &quot;readingTime&quot;: 13]], &quot;title&quot;: &quot;Articles&quot;, &quot;js&quot;: [], &quot;toc&quot;: [], &quot;css&quot;: [], &quot;slug&quot;: &quot;articles&quot;, &quot;publication&quot;: ToucanSDK.PageBundle.DateValue(html: &quot;March 08, 2025&quot;, rss: &quot;Sat, 08 Mar 2025 20:51:12 +0000&quot;, sitemap: &quot;2025-03-08&quot;), &quot;permalink&quot;: &quot;http://localhost:3000/articles/&quot;, &quot;canonical&quot;: &quot;http://localhost:3000/articles/&quot;, &quot;description&quot;: &quot;&quot;, &quot;readingTime&quot;: 1, &quot;lastModification&quot;: ToucanSDK.PageBundle.DateValue(html: &quot;March 08, 2025&quot;, rss: &quot;Sat, 08 Mar 2025 20:44:33 +0000&quot;, sitemap: &quot;2025-03-08&quot;), &quot;contents&quot;: &quot;&quot;, &quot;imageUrl&quot;: false]</h4>
                            
                            <div class="card">
                                <div class="meta">
                                    <time datetime="March 08, 2025">March 08, 2025</time>
                                     &middot; <span class="reading-time">1 min read</span>
                                </div>
                                
                                <h2 class="title"><a href="http://localhost:3000/articles/" target="">Articles</a></h2>
                                <p></p>
                            
                                <div class="spacer"></div>
                            
                                <div class="tag-list">
                                </div>
                            </div>
        <h4>[&quot;toc&quot;: [ToucanSDK.ToCNode(level: 2, text: &quot;Why Swift?&quot;, fragment: &quot;why-swift&quot;, children: [ToucanSDK.ToCNode(level: 3, text: &quot;Playdate by Panic&quot;, fragment: &quot;playdate-by-panic&quot;, children: []), ToucanSDK.ToCNode(level: 3, text: &quot;The Embedded Language Mode&quot;, fragment: &quot;the-embedded-language-mode&quot;, children: [])]), ToucanSDK.ToCNode(level: 2, text: &quot;The Games&quot;, fragment: &quot;the-games&quot;, children: []), ToucanSDK.ToCNode(level: 2, text: &quot;Try it Out&quot;, fragment: &quot;try-it-out&quot;, children: []), ToucanSDK.ToCNode(level: 2, text: &quot;Deep Dive: Bringing Swift to the Playdate&quot;, fragment: &quot;deep-dive-bringing-swift-to-the-playdate&quot;, children: [ToucanSDK.ToCNode(level: 3, text: &quot;Building object files for the Playdate Simulator&quot;, fragment: &quot;building-object-files-for-the-playdate-simulator&quot;, children: []), ToucanSDK.ToCNode(level: 3, text: &quot;Importing the Playdate C API&quot;, fragment: &quot;importing-the-playdate-c-api&quot;, children: []), ToucanSDK.ToCNode(level: 3, text: &quot;Running on the Simulator&quot;, fragment: &quot;running-on-the-simulator&quot;, children: []), ToucanSDK.ToCNode(level: 3, text: &quot;Running on the Hardware&quot;, fragment: &quot;running-on-the-hardware&quot;, children: []), ToucanSDK.ToCNode(level: 3, text: &quot;Improving the API with Swift&quot;, fragment: &quot;improving-the-api-with-swift&quot;, children: []), ToucanSDK.ToCNode(level: 3, text: &quot;Completing Swift Break&quot;, fragment: &quot;completing-swift-break&quot;, children: []), ToucanSDK.ToCNode(level: 3, text: &quot;Running on the Hardware (Again!)&quot;, fragment: &quot;running-on-the-hardware-again&quot;, children: [])]), ToucanSDK.ToCNode(level: 2, text: &quot;Wrapping Up&quot;, fragment: &quot;wrapping-up&quot;, children: [])], &quot;imageUrl&quot;: false, &quot;prev&quot;: [[&quot;lastModification&quot;: ToucanSDK.PageBundle.DateValue(html: &quot;March 08, 2025&quot;, rss: &quot;Sat, 08 Mar 2025 20:44:33 +0000&quot;, sitemap: &quot;2025-03-08&quot;), &quot;imageUrl&quot;: false, &quot;toc&quot;: [], &quot;publication&quot;: ToucanSDK.PageBundle.DateValue(html: &quot;March 08, 2025&quot;, rss: &quot;Sat, 08 Mar 2025 20:51:12 +0000&quot;, sitemap: &quot;2025-03-08&quot;), &quot;css&quot;: [], &quot;canonical&quot;: &quot;http://localhost:3000/articles/&quot;, &quot;readingTime&quot;: 1, &quot;js&quot;: [], &quot;title&quot;: &quot;Articles&quot;, &quot;permalink&quot;: &quot;http://localhost:3000/articles/&quot;, &quot;description&quot;: &quot;&quot;, &quot;slug&quot;: &quot;articles&quot;, &quot;contents&quot;: &quot;&quot;]], &quot;lastModification&quot;: ToucanSDK.PageBundle.DateValue(html: &quot;March 08, 2025&quot;, rss: &quot;Sat, 08 Mar 2025 19:53:28 +0000&quot;, sitemap: &quot;2025-03-08&quot;), &quot;slug&quot;: &quot;articles/2024-03-12-byte-sized-swift-tiny-games-playdate&quot;, &quot;contents&quot;: &quot;&lt;p&gt;I‚Äôm excited to share &lt;a href=\&quot;https://github.com/apple/swift-playdate-examples\&quot; target=\&quot;_blank\&quot;&gt;swift-playdate-examples&lt;/a&gt;, a technical demonstration of using Swift to build games for &lt;a href=\&quot;https://play.date/\&quot; target=\&quot;_blank\&quot;&gt;Playdate&lt;/a&gt;, a handheld game system by &lt;a href=\&quot;https://panic.com\&quot; target=\&quot;_blank\&quot;&gt;Panic&lt;/a&gt;.&lt;/p&gt;&lt;video title=\&quot;A screencapture of Swift Break running on Playdate hardware mirrored to a Mac.\&quot; autoplay loop muted style=\&quot;width: 100%; border-radius: 15px;\&quot;&gt;\n  &lt;source src=\&quot;{{site.url}}/assets/images/2024-03-12-byte-sized-swift-tiny-games-playdate/playdate-mirror-video-swiftbreak.mp4\&quot; type=\&quot;video/mp4\&quot;&gt;\n&lt;/video&gt;\n&lt;h2 id=\&quot;why-swift\&quot;&gt;Why Swift?&lt;/h2&gt;&lt;p&gt;Swift is widely known as the modern language for app development on Apple devices. However, over the course of its first decade, it has grown into a versatile, multi-platform language targeting use cases where you‚Äôd otherwise find C or C++.&lt;/p&gt;&lt;p&gt;Personally, I have come to appreciate Swift‚Äôs emphasis on memory safety and great ergonomics, and want these traits for embedded systems where reliability and security are critically important.&lt;/p&gt;&lt;p&gt;But embedded systems are not only found in mission-critical applications. Some are actually all fun and &lt;em&gt;games&lt;/em&gt;.&lt;/p&gt;&lt;h3 id=\&quot;playdate-by-panic\&quot;&gt;Playdate by Panic&lt;/h3&gt;&lt;p&gt;Over the holiday season, I read about building Playdate games in C and became curious if the same was possible in Swift. For those unfamiliar with Playdate, it is a tiny handheld game system built by Panic, creators of popular apps and games like ‚ÄúTransmit,‚Äù ‚ÄúNova,‚Äù ‚ÄúFirewatch,‚Äù ‚ÄúUntitled Goose Game,‚Äù and more. It houses a Cortex M7 processor, a 400 by 240 1-bit display, and has a small runtime for hosting games. Additionally, Panic provides an &lt;a href=\&quot;https://play.date/dev/\&quot; target=\&quot;_blank\&quot;&gt;SDK&lt;/a&gt; for building games in both C and Lua.&lt;/p&gt;&lt;p&gt;While most Playdate games are written in Lua for ease of development, they can run into performance problems that necessitate the added complexity of using C. Swift‚Äôs combination of high-level ergonomics with low-level performance, as well as its strong support for interoperating with C, make it seem like a good match for the Playdate. However, the typical Swift application and runtime exceed the device‚Äôs tight resource constraints.&lt;/p&gt;&lt;p&gt;Regardless, I still wanted to create a game in Swift and I had a good idea for the approach.&lt;/p&gt;&lt;h3 id=\&quot;the-embedded-language-mode\&quot;&gt;The Embedded Language Mode&lt;/h3&gt;&lt;p&gt;Recently, the Swift project began developing a new embedded language mode to support highly constrained platforms. This mode utilizes generic specialization, inlining, and dead code stripping to produce tiny binaries, while retaining the core features of Swift.&lt;/p&gt;&lt;blockquote class=\&quot;note\&quot;&gt;&lt;p&gt;Note: The embedded language mode is actively evolving and is helping drive the development of language features such as: &lt;a href=\&quot;https://github.com/swiftlang/swift-evolution/blob/main/proposals/0390-noncopyable-structs-and-enums.md\&quot; target=\&quot;_blank\&quot;&gt;non-copyable types&lt;/a&gt;, &lt;a href=\&quot;https://github.com/swiftlang/swift-evolution/blob/main/proposals/0413-typed-throws.md\&quot; target=\&quot;_blank\&quot;&gt;typed throws&lt;/a&gt;, etc. It is available now in &lt;a href=\&quot;https://www.swift.org/download/\&quot; target=\&quot;_blank\&quot;&gt;nightly toolchains&lt;/a&gt; and if you‚Äôre curious to learn more, check out the &lt;a href=\&quot;https://github.com/swiftlang/swift-evolution/blob/main/visions/embedded-swift.md\&quot; target=\&quot;_blank\&quot;&gt;Vision for Embedded Swift&lt;/a&gt;.&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;These defining characteristics make the embedded language mode a great solution for shrinking Swift to fit the Playdate‚Äôs constraints.&lt;/p&gt;&lt;p&gt;With the embedded Swift language mode in hand, I got to work.&lt;/p&gt;&lt;h2 id=\&quot;the-games\&quot;&gt;The Games&lt;/h2&gt;&lt;p&gt;I wrote two small games in Swift for the Playdate. The first game is a port of the Playdate SDK sample of &lt;a href=\&quot;https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life\&quot; target=\&quot;_blank\&quot;&gt;Conway‚Äôs Game of Life&lt;/a&gt; into Swift:&lt;/p&gt;&lt;p&gt;    &lt;img src=\&quot;/assets/images/2024-03-12-byte-sized-swift-tiny-games-playdate/playdate-simulator-still-life.png\&quot; alt=\&quot;A screenshot of the Playdate Simulator running Conway‚Äôs Game of Life.\&quot;&gt;&lt;/p&gt;&lt;p&gt;This game is one Swift file that builds directly against the Playdate C API and does not require dynamic memory allocation. The packaged game clocks in at 788 bytes, slightly smaller than the C example, which is 904 bytes.&lt;/p&gt;&lt;pre&gt;&lt;code class=\&quot;language-shell\&quot;&gt;$ wc -c &amp;lt; $REPO_ROOT/Examples/Life/Life.pdx/pdex.bin\n     788\n\n$ wc -c &amp;lt; $HOME/Developer/PlaydateSDK/C_API/Examples/GameOfLife.pdx/pdex.bin\n     904\n&lt;/code&gt;&lt;/pre&gt;&lt;blockquote class=\&quot;note\&quot;&gt;&lt;p&gt;Note: Both versions could likely be made smaller, but I did not try to optimize code size.&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;The second game is a paddle-and-ball style game named ‚ÄúSwift Break.‚Äù&lt;/p&gt;&lt;p&gt;    &lt;img src=\&quot;/assets/images/2024-03-12-byte-sized-swift-tiny-games-playdate/playdate-simulator-still-swiftbreak.png\&quot; alt=\&quot;A screenshot of the Playdate Simulator with the Swift Break splash screen.\&quot;&gt;&lt;/p&gt;&lt;p&gt;Swift Break uses the same high-level language features you‚Äôd find in desktop and server applications, such as &lt;a href=\&quot;https://docs.swift.org/swift-book/documentation/the-swift-programming-language/enumerations/#Associated-Values\&quot; target=\&quot;_blank\&quot;&gt;enums with associated values&lt;/a&gt;, &lt;a href=\&quot;https://docs.swift.org/swift-book/documentation/the-swift-programming-language/generics\&quot; target=\&quot;_blank\&quot;&gt;generic types and functions&lt;/a&gt;, and &lt;a href=\&quot;https://docs.swift.org/swift-book/documentation/the-swift-programming-language/memorysafety\&quot; target=\&quot;_blank\&quot;&gt;automatic memory management&lt;/a&gt; to simplify game development while retaining C-level performance.&lt;/p&gt;&lt;p&gt;For example, here‚Äôs the core game logic for handling ball bounces:&lt;/p&gt;&lt;pre&gt;&lt;code class=\&quot;language-swift\&quot;&gt;sprite.moveWithCollisions(goalX: newX, goalY: newY) { _, _, collisions in\n  for collision in collisions {\n    let otherSprite = Sprite(borrowing: collision.other)\n\n    // If we hit a visible brick, remove it.\n    if otherSprite.tag == .brick, otherSprite.isVisible {\n      otherSprite.removeSprite()\n      activeGame.bricksRemaining -= 1\n    }\n\n    var normal = Vector(collision.normal)\n\n    if otherSprite.tag == .paddle {\n      // Compute deflection angle (radians) for the normal in domain\n      // -pi/6 to pi/6.\n      let placement = placement(of: collision, along: otherSprite)\n      let deflectionAngle = placement * (.pi / 6)\n      normal.rotate(by: deflectionAngle)\n    }\n\n    activeGame.ballVelocity.reflect(along: normal)\n  }\n}\n&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;It calls a &lt;code&gt;moveWithCollisions&lt;/code&gt; method to move the ball, iterating through a collection of objects the ball bounced off of while moving.&lt;/p&gt;&lt;p&gt;Swift Break features a splash screen, a pause menu, paddle-location-based bounce physics, infinite levels, a game over screen, and allows you to control the paddle with either the D-Pad or the Crank!&lt;/p&gt;&lt;h2 id=\&quot;try-it-out\&quot;&gt;Try it Out&lt;/h2&gt;&lt;p&gt;If you‚Äôre eager to use Swift on your Playdate, the &lt;a href=\&quot;https://github.com/apple/swift-playdate-examples\&quot; target=\&quot;_blank\&quot;&gt;swift-playdate-examples&lt;/a&gt; repository has you covered. It contains the above ready-to-use examples that demonstrate how to build Swift games for the Playdate, both for the simulator and the hardware.&lt;/p&gt;&lt;p&gt;Additionally, the repository includes detailed documentation to guide you through the setup process. Whether you‚Äôre a seasoned developer or just starting, you‚Äôll find the necessary resources to bring your ideas to life.&lt;/p&gt;&lt;p&gt;But if you‚Äôre up for a deep dive into the technical details of what it takes to bring Swift to a new platform, read on!&lt;/p&gt;&lt;h2 id=\&quot;deep-dive-bringing-swift-to-the-playdate\&quot;&gt;Deep Dive: Bringing Swift to the Playdate&lt;/h2&gt;&lt;p&gt;Bringing up a new platform is always fraught with challenges and infuriating bugs. Everything is broken with numerous false starts, until you clear the last bug, and then it all comes together. Getting Swift games running on the Playdate was no different.&lt;/p&gt;&lt;p&gt;My general approach was to leverage Swift‚Äôs interoperability to build on top of the Playdate C SDK. The good news is that the Swift toolchain already had all the features I needed to get this working. I just had to figure out how to put them together. Here‚Äôs an overview of the path I took:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Building object files for the Playdate Simulator&lt;/li&gt;&lt;li&gt;Importing the Playdate C API&lt;/li&gt;&lt;li&gt;Running on the Simulator&lt;/li&gt;&lt;li&gt;Running on the Hardware&lt;/li&gt;&lt;li&gt;Improving the API with Swift&lt;/li&gt;&lt;li&gt;Completing Swift Break&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;Without further ado, let‚Äôs get started.&lt;/p&gt;&lt;h3 id=\&quot;building-object-files-for-the-playdate-simulator\&quot;&gt;Building object files for the Playdate Simulator&lt;/h3&gt;&lt;blockquote class=\&quot;note\&quot;&gt;&lt;p&gt;Note: The commands mentioned below were run with a Swift nightly toolchain installed and have the &lt;code&gt;TOOLCHAINS&lt;/code&gt; environment variable set to the name of the toolchain.&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;My first step was compiling an object file for the Playdate Simulator. The simulator works by dynamically loading host libraries, so I needed to build the object files for the host‚Äôs platform and architecture (the so-called &lt;em&gt;triple&lt;/em&gt; in compiler-speak), which &lt;code&gt;swiftc&lt;/code&gt; does by default. The only additional flags I needed were for enabling embedded Swift and code optimizations.&lt;/p&gt;&lt;pre&gt;&lt;code class=\&quot;language-shell\&quot;&gt;$ cat test.swift\nlet value = 1\n\n$ mkdir build\n\n$ swiftc -c test.swift -o build/test.o \\\n    -Osize -wmo -enable-experimental-feature Embedded\n\n$ file build/test.o\ntest.o: Mach-O 64-bit object arm64\n&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=\&quot;importing-the-playdate-c-api\&quot;&gt;Importing the Playdate C API&lt;/h3&gt;&lt;p&gt;The next step was compiling against the Playdate C API from Swift. This was straightforward due to the structure of the Playdate C header files and Swift‚Äôs native support for interoperating with C.&lt;/p&gt;&lt;p&gt;I started by locating the Playdate C header files:&lt;/p&gt;&lt;pre&gt;&lt;code class=\&quot;language-shell\&quot;&gt;$ ls $HOME/Developer/PlaydateSDK/C_API/\nExamples     buildsupport pd_api       pd_api.h\n\n$ ls $HOME/Developer/PlaydateSDK/C_API/pd_api\npd_api_display.h     pd_api_gfx.h         pd_api_lua.h         pd_api_sound.h       pd_api_sys.h\npd_api_file.h        pd_api_json.h        pd_api_scoreboards.h pd_api_sprite.h\n&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;And used an ‚Äúinclude search path‚Äù (&lt;code&gt;-I&lt;/code&gt;) to tell the Swift compiler‚Äôs C interoperability feature where to find them. I additionally needed to pass a ‚Äúdefine‚Äù (&lt;code&gt;-D&lt;/code&gt;) to tell the compiler how to parse the header files:&lt;/p&gt;&lt;pre&gt;&lt;code class=\&quot;language-shell\&quot;&gt;$ swiftc ... -Xcc -I -Xcc $HOME/Developer/PlaydateSDK/C_API/ -Xcc -DTARGET_EXTENSION\n&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Next, I created a &lt;a href=\&quot;https://clang.llvm.org/docs/Modules.html#module-maps\&quot; target=\&quot;_blank\&quot;&gt;module map file&lt;/a&gt; to wrap the headers into an importable module from Swift:&lt;/p&gt;&lt;pre&gt;&lt;code class=\&quot;language-shell\&quot;&gt;$ cat $HOME/Developer/PlaydateSDK/C_API/module.modulemap\nmodule CPlaydate [system] {\n  umbrella header \&quot;pd_api.h\&quot;\n  export *\n}\n&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;And used an ‚Äúimport search path‚Äù (&lt;code&gt;-I&lt;/code&gt;) to tell the Swift compiler where to find the CPlaydate module:&lt;/p&gt;&lt;pre&gt;&lt;code class=\&quot;language-shell\&quot;&gt;$ swiftc ... -I $HOME/Developer/PlaydateSDK/C_API/\n&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Lastly, I made a minimal ‚Äúlibrary‚Äù using the Playdate C API from Swift and compiled using the flags above:&lt;/p&gt;&lt;pre&gt;&lt;code class=\&quot;language-shell\&quot;&gt;$ cat test.swift\nimport CPlaydate\nlet pd: UnsafePointer&amp;lt;PlaydateAPI&amp;gt;? = nil\n\n$ mkdir build\n\n$ swiftc \\\n    -c test.swift \\\n    -o build/test.o \\\n    -Osize -wmo -enable-experimental-feature Embedded \\\n    -Xcc -I -Xcc $HOME/Developer/PlaydateSDK/C_API/ \\\n    -Xcc -DTARGET_EXTENSION \\\n    -I $HOME/Developer/PlaydateSDK/C_API/\n\n$ file build/test.o\ntest.o: Mach-O 64-bit object arm64\n&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=\&quot;running-on-the-simulator\&quot;&gt;Running on the Simulator&lt;/h3&gt;&lt;p&gt;Once I was able to use the Playdate C API from Swift, I ported the Conway‚Äôs Game of Life example included in the Playdate SDK to Swift, referencing &lt;a href=\&quot;https://sdk.play.date/2.2.0/Inside%20Playdate%20with%20C.html\&quot; target=\&quot;_blank\&quot;&gt;Inside Playdate with C&lt;/a&gt; frequently to familiarize myself with the API.&lt;/p&gt;&lt;p&gt;The C implementation of Conway‚Äôs strictly operates on Playdate OS-vended frame buffers and uses the display as game state, removing the need for separate data structures and dynamic allocations. As a result, the porting process was very mechanical because the bit manipulation and pointer operations in the C example have direct Swift analogs:&lt;/p&gt;&lt;pre&gt;&lt;code class=\&quot;language-c\&quot;&gt;static inline int val(uint8_t* row, int x) {\n    return 1 - ((row[x/8] &amp;gt;&amp;gt; (7 - (x%8))) &amp; 1);\n}\n\nstatic inline int ison(uint8_t* row, int x) {\n    return !(row[x/8] &amp; (0x80 &amp;gt;&amp;gt; (x%8)));\n}\n&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code class=\&quot;language-swift\&quot;&gt;struct Row {\n  var buffer: UnsafeMutablePointer&amp;lt;UInt8&amp;gt;\n\n  func value(at column: Int32) -&amp;gt; UInt8 {\n    isOn(at: column) ? 1 : 0\n  }\n\n  func isOn(at column: Int32) -&amp;gt; Bool {\n    let byte = buffer[Int(column / 8)]\n    let bitPosition = 0x80 &amp;gt;&amp;gt; (column % 8)\n    return (byte &amp; bitPosition) == 0\n  }\n}\n&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;I built the source into a dynamic library and used &lt;code&gt;pdc&lt;/code&gt; (the Playdate compiler) to wrap the final &lt;code&gt;dylib&lt;/code&gt; into a &lt;code&gt;pdx&lt;/code&gt; (Playdate executable).&lt;/p&gt;&lt;pre&gt;&lt;code class=\&quot;language-shell\&quot;&gt;$ swiftc \\\n    -emit-library test.swift \\\n    -o build/pdex.dylib \\\n    ...\n\n$ file build/pdex.dylib\npdex.dylib: Mach-O 64-bit dynamically linked shared library arm64\n\n$ $HOME/Developer/PlaydateSDK/bin/pdc build Test\n\n$ ls Test.pdx\npdex.dylib pdxinfo\n&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;I opened my game file &lt;code&gt;Test.pdx&lt;/code&gt; using the Playdate simulator and as you might expect, it worked on the first try ‚Ä¶ just kidding, it crashed!&lt;/p&gt;&lt;p&gt;After some debugging, I realized the &lt;code&gt;Makefile&lt;/code&gt; used to compile the C example included an additional file &lt;code&gt;setup.c&lt;/code&gt; from the SDK containing the symbol &lt;code&gt;_eventHandlerShim&lt;/code&gt; needed to bootstrap the game. If this symbol is not present in the binary, the Simulator falls back to bootstrapping the game using the symbol &lt;code&gt;_eventHandler&lt;/code&gt; which my binary did contain, but meant my game skipped an important setup step.&lt;/p&gt;&lt;p&gt;So, I compiled &lt;code&gt;setup.c&lt;/code&gt; into an object file using &lt;code&gt;clang&lt;/code&gt;, linked it into my dynamic library, re-ran, and voila! I had Conway‚Äôs Game of Life written in Swift running on the Playdate Simulator.&lt;/p&gt;&lt;h3 id=\&quot;running-on-the-hardware\&quot;&gt;Running on the Hardware&lt;/h3&gt;&lt;p&gt;After successfully running on the simulator, I wanted to run the game on real hardware. A colleague graciously allowed me to borrow their Playdate and I began hacking away.&lt;/p&gt;&lt;p&gt;I started by matching the triple used by the C examples for the device and seeing what happened.&lt;/p&gt;&lt;pre&gt;&lt;code class=\&quot;language-shell\&quot;&gt;$ swiftc ... -target armv7em-none-none-eabi\n&amp;lt;module-includes&amp;gt;:1:10: note: in file included from &amp;lt;module-includes&amp;gt;:1:\n#include \&quot;pd_api.h\&quot;\n         ^\n$HOME/Developer/PlaydateSDK/C_API/pd_api.h:13:10: error: \&#39;stdlib.h\&#39; file not found\n#include &amp;lt;stdlib.h&amp;gt;\n         ^\n&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;These errors did not previously occur because I was targeting the host machine and used the host headers for the C standard library. I considered using the same host headers for the target device, but didn‚Äôt want to debug platform incompatibilities. Little did I know, I would have to do this regardless.&lt;/p&gt;&lt;p&gt;Instead, I decided to follow the route used by the C example programs which leverage the libc headers from a &lt;code&gt;gcc&lt;/code&gt; toolchain installed with the Playdate SDK. I copied the include paths used by the C examples and re-ran the compile.&lt;/p&gt;&lt;pre&gt;&lt;code class=\&quot;language-shell\&quot;&gt;$ mkdir build\n\n$ GCC_LIB=/usr/local/playdate/gcc-arm-none-eabi-9-2019-q4-major/lib\n\n$ swiftc \\\n    -c test.swift \\\n    -o build/test.o \\\n    -target armv7em-none-none-eabi \\\n    -Osize -wmo -enable-experimental-feature Embedded \\\n    -I $HOME/Developer/PlaydateSDK/C_API/ \\\n    -Xcc -DTARGET_EXTENSION \\\n    -Xcc -I -Xcc $HOME/Developer/PlaydateSDK/C_API/ \\\n    -Xcc -I -Xcc $GCC_LIB/gcc/arm-none-eabi/9.2.1/include \\\n    -Xcc -I -Xcc $GCC_LIB/gcc/arm-none-eabi/9.2.1/include-fixed \\\n    -Xcc -I -Xcc $GCC_LIB/gcc/arm-none-eabi/9.2.1/../../../../arm-none-eabi/include\n\n$ file build/test.o\ntest.o: ELF 32-bit LSB relocatable, ARM, EABI5 version 1 (SYSV), not stripped\n&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The compile succeeded and I had an object file for the real hardware. I went through similar steps to link and package the object file into a &lt;code&gt;pdx&lt;/code&gt;, using &lt;code&gt;clang&lt;/code&gt; as the linker driver.&lt;/p&gt;&lt;p&gt;I deployed the game onto a Playdate, and ‚Ä¶ it crashed.&lt;/p&gt;&lt;p&gt;For some reason, when the frame-update function pointer was called, the game would crash! Debugging this issue was confusing at first, but due to past experience deploying Swift onto a Cortex M7, I realized I likely had a calling convention mismatch. I added a compiler flag &lt;code&gt;-Xfrontend -experimental-platform-c-calling-convention=arm_aapcs_vfp&lt;/code&gt; to try to match the calling convention used by the Playdate OS.&lt;/p&gt;&lt;p&gt;Once again, I deployed my game to the Playdate and ‚Ä¶ it actually worked! You can see the game in action below:&lt;/p&gt;&lt;video title=\&quot;A video of Conway\&#39;s Game of Life running on Playdate hardware mirrored to a Mac.\&quot; autoplay loop muted style=\&quot;width: 100%; border-radius: 15px;\&quot;&gt;\n  &lt;source src=\&quot;{{site.url}}/assets/images/2024-03-12-byte-sized-swift-tiny-games-playdate/playdate-mirror-video-life.mp4\&quot; type=\&quot;video/mp4\&quot;&gt;\n&lt;/video&gt;\n&lt;p&gt;I then integrated my manual compilation steps into the Makefiles found in the Playdate SDK, going through a number of options before landing on the final solution found in &lt;code&gt;swift-playdate-examples&lt;/code&gt;. The result of this effort was a single &lt;code&gt;make&lt;/code&gt; command to build a &lt;code&gt;pdx&lt;/code&gt; compatible with both the simulator and hardware!&lt;/p&gt;&lt;h3 id=\&quot;improving-the-api-with-swift\&quot;&gt;Improving the API with Swift&lt;/h3&gt;&lt;p&gt;After porting Conway‚Äôs Game of Life, I began a more ambitious project: a paddle-and-ball style game named Swift Break. However, I quickly encountered friction using the raw Playdate C API directly in Swift. In typical programming fashion, I took a detour to work on the API‚Äôs ergonomics instead of the game! At this point, I had also piqued the interest of some colleagues who contributed further improvements.&lt;/p&gt;&lt;p&gt;One hurdle was the naming conventions of the imported API. In C, enum cases are often prefixed with their type‚Äôs name to prevent programmers from inadvertently mixing unrelated enum instances and case constants. However, in Swift, such prefixes are unnecessary as the compiler type-checks comparisons to ensure the correct cases are used.&lt;/p&gt;&lt;p&gt;Fortunately, Swift already provides tools for addressing this precise issue, known as &lt;a href=\&quot;https://clang.llvm.org/docs/APINotes.html\&quot; target=\&quot;_blank\&quot;&gt;API notes&lt;/a&gt;. I added an API notes file to the Playdate SDK and renamed enum cases with more idiomatic Swift names:&lt;/p&gt;&lt;pre&gt;&lt;code class=\&quot;language-swift\&quot;&gt;// Before\nif event == kEventPause { ... }\n\n// After\nif event == .pause { ... }\n&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;A bigger issue, however, was the lack of nullability annotations in the C API. This meant the generated code had redundant null checks everywhere, bloating code size and hurting performance. While I usually would have used API notes to add the missing annotations, this was not possible. The C API uses structs with function pointers as a ‚Äúvtable‚Äù, and unfortunately, these are not currently modifiable with API notes. Due to this incompatibility, I had to adopt a suboptimal solution: pervasively using &lt;code&gt;Optional.unsafelyUnwrapped&lt;/code&gt; throughout the Swift code.&lt;/p&gt;&lt;p&gt;Although this approach eliminated the null checks, it dramatically hurt readability:&lt;/p&gt;&lt;pre&gt;&lt;code class=\&quot;language-swift\&quot;&gt;// C API in Swift with redundant null checks\nlet spritePointer = playdate_api.pointee.sprite.pointee.newSprite()\n\n// C API in Swift without redundant null checks\nlet spritePointer = playdate_api.unsafelyUnwrapped.pointee.sprite.unsafelyUnwrapped.pointee.newSprite.unsafelyUnwrapped()\n&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;To address the readability issues, I created a thin Swift overlay on top of the C API. I wrapped function pointer accesses into static and instance methods on Swift types and converted function get/set pairs to Swift properties. Creating a sprite became much more intuitive and introduced zero overhead on top of the equivalent imported C calls.&lt;/p&gt;&lt;pre&gt;&lt;code class=\&quot;language-swift\&quot;&gt;var sprite = Sprite(bitmapPath: \&quot;background.png\&quot;)\nsprite.collisionsEnabled = false\nsprite.zIndex = 0\nsprite.addSprite()\n&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Colleagues further improved the overlay by abstracting Playdate APIs requiring manual memory management to be automatically handled. An excellent example is the C API‚Äôs &lt;a href=\&quot;https://sdk.play.date/2.2.0/Inside%20Playdate%20with%20C.html#f-sprite.moveWithCollisions\&quot; target=\&quot;_blank\&quot;&gt;&lt;code&gt;moveWithCollisions&lt;/code&gt;&lt;/a&gt; function, which returns a buffer of &lt;code&gt;SpriteCollisionInfo&lt;/code&gt; structs that must be freed by the caller. Using the overlay allowed us to avoid manually deallocating the buffer and made the API easier to use:&lt;/p&gt;&lt;pre&gt;&lt;code class=\&quot;language-swift\&quot;&gt;// moveWithCollisions without the overlay\nvar count: Int32 = 0\nvar actualX: Int32 = 0\nvar actualY: Int32 = 0\nlet collisionsStartAddress = playdate_api.pointee.sprite.pointee.moveWithCollisions(sprite, 10, 10, &amp;actualX, &amp;actualY, &amp;count)\nlet collisions = UnsafeBufferPointer(start: collisionsStartAddress, count: count)\ndefer { collisions.deallocate() }\nfor collision in collisions { ... }\n\n// moveWithCollisions with the overlay\nsprite.moveWithCollisions(goalX: 10, goalY: 10) { actualX, actualY, collisions in\n    for collision in collisions { ... }\n}\n&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;These improvements dramatically streamlined writing code for the Playdate. Additionally, as Swift‚Äôs support for ownership and non-copyable types improves, I anticipate even more ergonomic representations of the C APIs without language overhead.&lt;/p&gt;&lt;h3 id=\&quot;completing-swift-break\&quot;&gt;Completing Swift Break&lt;/h3&gt;&lt;p&gt;Equipped with a refined Swift Playdate API, I returned to developing Swift Break.&lt;/p&gt;&lt;p&gt;I nailed down the basics pretty quickly, but couldn‚Äôt resist adding extra features just for the fun of it. One of the highlights was implementing basic logic to deflect ball bounces based on the location where the ball and paddle collide.&lt;/p&gt;&lt;p&gt;This feature required calculating a normal vector relative to a hypothetical curve representing a rounded paddle and then reflecting the ball‚Äôs velocity about the normal. Here‚Äôs a visualization of the intended behavior:&lt;/p&gt;&lt;video title=\&quot;A Desmos geometric animation of Swift Break ball bouncing logic.\&quot; autoplay loop muted style=\&quot;width: 100%; border-radius: 15px;\&quot;&gt;\n  &lt;source src=\&quot;{{site.url}}/assets/images/2024-03-12-byte-sized-swift-tiny-games-playdate/desmos-ball-bounce.mp4\&quot; type=\&quot;video/mp4\&quot;&gt;\n&lt;/video&gt;\n&lt;blockquote class=\&quot;note\&quot;&gt;&lt;p&gt;Note: Making the animation for this post ironically helped me root cause a bug in the bouncing logic. Under some combinations of entry angle and normal angle, the current design can cause the ball to bounce &lt;em&gt;down&lt;/em&gt; into the paddle instead of up.&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;To turn the math into an algorithm, I had to perform the following steps:&lt;/p&gt;&lt;ol&gt;&lt;li&gt;Check if the object the ball collided with is the paddle&lt;/li&gt;&lt;li&gt;Compute the location of the collision along the paddle from -1 to +1&lt;/li&gt;&lt;li&gt;Map the location into a deflection angle from from -œÄ/6 to +œÄ/6&lt;/li&gt;&lt;li&gt;Rotate the collision normal vector by the deflection angle&lt;/li&gt;&lt;li&gt;Reflect the ball‚Äôs velocity along the rotated normal&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;I then directly translated this algorithm into code inside the ball collision callback:&lt;/p&gt;&lt;pre&gt;&lt;code class=\&quot;language-swift\&quot;&gt;if otherSprite.tag == .paddle {                                // 1\n  let placement = placement(of: collision, along: otherSprite) // 2\n  let deflectionAngle = placement * (.pi / 6)                  // 3\n  normal.rotate(by: deflectionAngle)                           // 4\n}\nballVelocity.reflect(along: normal)                            // 5\n&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=\&quot;running-on-the-hardware-again\&quot;&gt;Running on the Hardware (Again!)&lt;/h3&gt;&lt;p&gt;Throughout the development of ‚ÄúSwift Break,‚Äù I regularly deployed the game to the Playdate Simulator. However, the real challenge emerged when I decided to run the game on actual Playdate hardware. As usual, I loaded the game, and ‚Ä¶ yet again, it crashed, but this time a lot of things were going wrong.&lt;/p&gt;&lt;p&gt;To cut a long debugging story short, I found that the &lt;code&gt;-Xfrontend&lt;/code&gt; flag mentioned earlier did not entirely resolve the calling convention issues. To address this, I needed to configure the compiler to match the CPU and floating-point ABI of the microcontroller in the Playdate. This aspect was overlooked when I was porting Conway‚Äôs Game of Life since I happened to both not pass structs by value and didn‚Äôt use floating-point operations.&lt;/p&gt;&lt;p&gt;The final and most confusing crash arose from a specific Playdate C API call returning an enum from the Playdate OS. After a thorough debugging process, e.g. using &lt;code&gt;printf&lt;/code&gt; everywhere, I uncovered a discrepancy in the memory layout of the enum between the system built with &lt;code&gt;gcc&lt;/code&gt; and the game built with &lt;code&gt;swiftc&lt;/code&gt;. With further research I found the difference stemmed from &lt;code&gt;gcc&lt;/code&gt; defaulting to &lt;code&gt;-fshort-enums&lt;/code&gt; while &lt;code&gt;swiftc&lt;/code&gt; via &lt;code&gt;clang&lt;/code&gt; used &lt;code&gt;-fno-short-enums&lt;/code&gt; for the &lt;code&gt;armv7em-none-none-eabi&lt;/code&gt; triple.&lt;/p&gt;&lt;p&gt;I collected these new and removed flags into the following compile command:&lt;/p&gt;&lt;pre&gt;&lt;code class=\&quot;language-shell\&quot;&gt;$ swiftc \\\n    -c test.swift \\\n    -o build/test.o \\\n    -target armv7em-none-none-eabi \\\n    -Osize -wmo -enable-experimental-feature Embedded \\\n    -I $HOME/Developer/PlaydateSDK/C_API \\\n    -Xcc -D__FPU_USED=1 \\\n    -Xcc -DTARGET_EXTENSION \\\n    -Xcc -falign-functions=16 \\\n    -Xcc -fshort-enums \\\n    -Xcc -mcpu=cortex-m7 \\\n    -Xcc -mfloat-abi=hard \\\n    -Xcc -mfpu=fpv5-sp-d16 \\\n    -Xcc -mthumb \\\n    -Xcc -I -Xcc $HOME/Developer/PlaydateSDK/C_API/ \\\n    -Xcc -I -Xcc $GCC_LIB/gcc/arm-none-eabi/9.2.1/include \\\n    -Xcc -I -Xcc $GCC_LIB/gcc/arm-none-eabi/9.2.1/include-fixed \\\n    -Xcc -I -Xcc $GCC_LIB/gcc/arm-none-eabi/9.2.1/../../../../arm-none-eabi/include \\\n    -Xfrontend -disable-stack-protector \\\n    -Xfrontend -experimental-platform-c-calling-convention=arm_aapcs_vfp \\\n    -Xfrontend -function-sections\n&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;With these adjustments, I attempted once more, and &lt;em&gt;finally&lt;/em&gt; ‚ÄúSwift Break‚Äù successfully ran on the Playdate hardware! I‚Äôve included a brief video showcasing the game below:&lt;/p&gt;&lt;video title=\&quot;A screencapture of Swift Break running on Playdate hardware mirrored to a Mac.\&quot; autoplay loop muted style=\&quot;width: 100%; border-radius: 15px;\&quot;&gt;\n  &lt;source src=\&quot;{{site.url}}/assets/images/2024-03-12-byte-sized-swift-tiny-games-playdate/playdate-mirror-video-swiftbreak.mp4\&quot; type=\&quot;video/mp4\&quot;&gt;\n&lt;/video&gt;\n&lt;h2 id=\&quot;wrapping-up\&quot;&gt;Wrapping Up&lt;/h2&gt;&lt;p&gt;Thanks for diving into the bring-up journey with me. From refining the Swift Playdate API to tackling issues involving calling conventions, CPU configurations, and memory layout disparities, there was no shortage of challenges.&lt;/p&gt;&lt;p&gt;However, with the issues now resolved, creating Playdate games in Swift is a streamlined process. Just run &lt;code&gt;make&lt;/code&gt; and enjoy a development experience with Swift that is both expressive &lt;em&gt;and&lt;/em&gt; performant.&lt;/p&gt;&lt;p&gt;You can find all the code examples mentioned in this post in the &lt;a href=\&quot;https://github.com/apple/swift-playdate-examples\&quot; target=\&quot;_blank\&quot;&gt;swift-playdate-examples&lt;/a&gt; repository with accompanying ‚ÄúGetting Started‚Äù documentation.&lt;/p&gt;&lt;p&gt;I hope this post encourages you to explore the possibilities of using Swift in unconventional environments. Feel free to reach out with your experiences, questions, or game ideas on the &lt;a href=\&quot;https://forums.swift.org/t/byte-sized-swift-building-tiny-games-for-the-playdate/70615\&quot; target=\&quot;_blank\&quot;&gt;Swift Forums&lt;/a&gt;!&lt;/p&gt;&lt;p&gt;Happy coding! üéÆ&lt;/p&gt;&quot;, &quot;title&quot;: &quot;Byte-sized Swift: Building Tiny Games for the Playdate&quot;, &quot;publication&quot;: ToucanSDK.PageBundle.DateValue(html: &quot;March 12, 2024&quot;, rss: &quot;Tue, 12 Mar 2024 10:00:00 +0000&quot;, sitemap: &quot;2024-03-12&quot;), &quot;js&quot;: [], &quot;next&quot;: [[&quot;publication&quot;: ToucanSDK.PageBundle.DateValue(html: &quot;May 16, 2022&quot;, rss: &quot;Mon, 16 May 2022 16:20:00 +0000&quot;, sitemap: &quot;2022-05-16&quot;), &quot;authors&quot;: [&quot;tibor-bodecs&quot;], &quot;readingTime&quot;: 1, &quot;css&quot;: [], &quot;js&quot;: [], &quot;imageUrl&quot;: false, &quot;title&quot;: &quot;Beginner\&#39;s guide to Swift package manager command plugins&quot;, &quot;tags&quot;: [&quot;swift-package-manager&quot;], &quot;permalink&quot;: &quot;http://localhost:3000/articles/test-post-2/&quot;, &quot;toc&quot;: [ToucanSDK.ToCNode(level: 2, text: &quot;Heading 2&quot;, fragment: &quot;heading-2&quot;, children: [ToucanSDK.ToCNode(level: 3, text: &quot;Heading 3&quot;, fragment: &quot;heading-3&quot;, children: [])])], &quot;contents&quot;: &quot;&lt;p&gt;Lorem ipsum dolor sit amet, consectetur adipiscing elit. Sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.&lt;/p&gt;&lt;h2 id=\&quot;heading-2\&quot;&gt;Heading 2&lt;/h2&gt;&lt;p&gt;Lorem ipsum dolor sit amet, consectetur adipiscing elit.  Aliquam erat volutpat.  Nulla quis ligula ipsum.  Suspendisse cursus faucibus est, ut ultricies ante euismod vitae.  Donec sit amet risus a risus aliquet vestibulum.  Maecenas sit amet orci eget eros faucibus tincidunt.  Duis leo.  Sed fringilla mauris sit amet nibh.  Donec sodales sagittis magna.  Sed consequat, leo eget bibendum sodales, augue velit cursus nunc, quis euismod sem libero ut magna.  Nam adipiscing.  Suspendisse potenti.&lt;/p&gt;&lt;h3 id=\&quot;heading-3\&quot;&gt;Heading 3&lt;/h3&gt;&lt;p&gt;Lorem ipsum dolor sit amet, consectetur adipiscing elit. Integer nec odio. Praesent libero. Sed cursus ante ac ante. Duis sagittis ipsum. Praesent mauris. Fusce accumsan massa. Quisque vitae magna.  Aenean tellus metus, bibendum sit amet, suscipit id, rutrum ac, nisi.  Nulla quis diam.  Nulla adipiscing.  In non turpis.  Curabitur purus.  Phasellus magna.  Vestibulum ante ipsum primis in faucibus orci luctus et ultrices posuere cubilia Curae;  Nulla tempor.  Mauris blandit aliquet elit.  Mauris nibh felis, adipiscing rhoncus, ultricies eu, bibendum non, nibh.  Suspendisse ultrices gravida.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Bold Text&lt;/strong&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;List item 1&lt;/li&gt;&lt;li&gt;List item 2&lt;/li&gt;&lt;li&gt;List item 3&lt;/li&gt;&lt;/ul&gt;&lt;ol&gt;&lt;li&gt;Numbered list item 1&lt;/li&gt;&lt;li&gt;Numbered list item 2&lt;/li&gt;&lt;li&gt;Numbered list item 3&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;a href=\&quot;https://www.example.com\&quot; target=\&quot;_blank\&quot;&gt;Link to Example&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;code&gt;Inline code&lt;/code&gt;&lt;/p&gt;&quot;, &quot;lastModification&quot;: ToucanSDK.PageBundle.DateValue(html: &quot;March 08, 2025&quot;, rss: &quot;Sat, 08 Mar 2025 19:53:38 +0000&quot;, sitemap: &quot;2025-03-08&quot;), &quot;canonical&quot;: &quot;http://localhost:3000/articles/test-post-2/&quot;, &quot;slug&quot;: &quot;articles/test-post-2&quot;, &quot;description&quot;: &quot;Learn how to create command plugins for the Swift Package Manager to execute custom actions using SPM and other tools.&quot;]], &quot;css&quot;: [], &quot;canonical&quot;: &quot;http://localhost:3000/articles/2024-03-12-byte-sized-swift-tiny-games-playdate/&quot;, &quot;permalink&quot;: &quot;http://localhost:3000/articles/2024-03-12-byte-sized-swift-tiny-games-playdate/&quot;, &quot;readingTime&quot;: 13, &quot;description&quot;: &quot;FIXME: Write this..&quot;]</h4>
                            
                            <div class="card">
                                <div class="meta">
                                    <time datetime="March 12, 2024">March 12, 2024</time>
                                     &middot; <span class="reading-time">13 min read</span>
                                </div>
                                
                                <h2 class="title"><a href="http://localhost:3000/articles/2024-03-12-byte-sized-swift-tiny-games-playdate/" target="">Byte-sized Swift: Building Tiny Games for the Playdate</a></h2>
                                <p>FIXME: Write this..</p>
                            
                                <div class="spacer"></div>
                            
                                <div class="tag-list">
                                </div>
                            </div>
        <h4>[&quot;toc&quot;: [ToucanSDK.ToCNode(level: 2, text: &quot;Heading 2&quot;, fragment: &quot;heading-2&quot;, children: [ToucanSDK.ToCNode(level: 3, text: &quot;Heading 3&quot;, fragment: &quot;heading-3&quot;, children: [])])], &quot;imageUrl&quot;: false, &quot;prev&quot;: [[&quot;readingTime&quot;: 13, &quot;css&quot;: [], &quot;publication&quot;: ToucanSDK.PageBundle.DateValue(html: &quot;March 12, 2024&quot;, rss: &quot;Tue, 12 Mar 2024 10:00:00 +0000&quot;, sitemap: &quot;2024-03-12&quot;), &quot;lastModification&quot;: ToucanSDK.PageBundle.DateValue(html: &quot;March 08, 2025&quot;, rss: &quot;Sat, 08 Mar 2025 19:53:28 +0000&quot;, sitemap: &quot;2025-03-08&quot;), &quot;permalink&quot;: &quot;http://localhost:3000/articles/2024-03-12-byte-sized-swift-tiny-games-playdate/&quot;, &quot;contents&quot;: &quot;&lt;p&gt;I‚Äôm excited to share &lt;a href=\&quot;https://github.com/apple/swift-playdate-examples\&quot; target=\&quot;_blank\&quot;&gt;swift-playdate-examples&lt;/a&gt;, a technical demonstration of using Swift to build games for &lt;a href=\&quot;https://play.date/\&quot; target=\&quot;_blank\&quot;&gt;Playdate&lt;/a&gt;, a handheld game system by &lt;a href=\&quot;https://panic.com\&quot; target=\&quot;_blank\&quot;&gt;Panic&lt;/a&gt;.&lt;/p&gt;&lt;video title=\&quot;A screencapture of Swift Break running on Playdate hardware mirrored to a Mac.\&quot; autoplay loop muted style=\&quot;width: 100%; border-radius: 15px;\&quot;&gt;\n  &lt;source src=\&quot;{{site.url}}/assets/images/2024-03-12-byte-sized-swift-tiny-games-playdate/playdate-mirror-video-swiftbreak.mp4\&quot; type=\&quot;video/mp4\&quot;&gt;\n&lt;/video&gt;\n&lt;h2 id=\&quot;why-swift\&quot;&gt;Why Swift?&lt;/h2&gt;&lt;p&gt;Swift is widely known as the modern language for app development on Apple devices. However, over the course of its first decade, it has grown into a versatile, multi-platform language targeting use cases where you‚Äôd otherwise find C or C++.&lt;/p&gt;&lt;p&gt;Personally, I have come to appreciate Swift‚Äôs emphasis on memory safety and great ergonomics, and want these traits for embedded systems where reliability and security are critically important.&lt;/p&gt;&lt;p&gt;But embedded systems are not only found in mission-critical applications. Some are actually all fun and &lt;em&gt;games&lt;/em&gt;.&lt;/p&gt;&lt;h3 id=\&quot;playdate-by-panic\&quot;&gt;Playdate by Panic&lt;/h3&gt;&lt;p&gt;Over the holiday season, I read about building Playdate games in C and became curious if the same was possible in Swift. For those unfamiliar with Playdate, it is a tiny handheld game system built by Panic, creators of popular apps and games like ‚ÄúTransmit,‚Äù ‚ÄúNova,‚Äù ‚ÄúFirewatch,‚Äù ‚ÄúUntitled Goose Game,‚Äù and more. It houses a Cortex M7 processor, a 400 by 240 1-bit display, and has a small runtime for hosting games. Additionally, Panic provides an &lt;a href=\&quot;https://play.date/dev/\&quot; target=\&quot;_blank\&quot;&gt;SDK&lt;/a&gt; for building games in both C and Lua.&lt;/p&gt;&lt;p&gt;While most Playdate games are written in Lua for ease of development, they can run into performance problems that necessitate the added complexity of using C. Swift‚Äôs combination of high-level ergonomics with low-level performance, as well as its strong support for interoperating with C, make it seem like a good match for the Playdate. However, the typical Swift application and runtime exceed the device‚Äôs tight resource constraints.&lt;/p&gt;&lt;p&gt;Regardless, I still wanted to create a game in Swift and I had a good idea for the approach.&lt;/p&gt;&lt;h3 id=\&quot;the-embedded-language-mode\&quot;&gt;The Embedded Language Mode&lt;/h3&gt;&lt;p&gt;Recently, the Swift project began developing a new embedded language mode to support highly constrained platforms. This mode utilizes generic specialization, inlining, and dead code stripping to produce tiny binaries, while retaining the core features of Swift.&lt;/p&gt;&lt;blockquote class=\&quot;note\&quot;&gt;&lt;p&gt;Note: The embedded language mode is actively evolving and is helping drive the development of language features such as: &lt;a href=\&quot;https://github.com/swiftlang/swift-evolution/blob/main/proposals/0390-noncopyable-structs-and-enums.md\&quot; target=\&quot;_blank\&quot;&gt;non-copyable types&lt;/a&gt;, &lt;a href=\&quot;https://github.com/swiftlang/swift-evolution/blob/main/proposals/0413-typed-throws.md\&quot; target=\&quot;_blank\&quot;&gt;typed throws&lt;/a&gt;, etc. It is available now in &lt;a href=\&quot;https://www.swift.org/download/\&quot; target=\&quot;_blank\&quot;&gt;nightly toolchains&lt;/a&gt; and if you‚Äôre curious to learn more, check out the &lt;a href=\&quot;https://github.com/swiftlang/swift-evolution/blob/main/visions/embedded-swift.md\&quot; target=\&quot;_blank\&quot;&gt;Vision for Embedded Swift&lt;/a&gt;.&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;These defining characteristics make the embedded language mode a great solution for shrinking Swift to fit the Playdate‚Äôs constraints.&lt;/p&gt;&lt;p&gt;With the embedded Swift language mode in hand, I got to work.&lt;/p&gt;&lt;h2 id=\&quot;the-games\&quot;&gt;The Games&lt;/h2&gt;&lt;p&gt;I wrote two small games in Swift for the Playdate. The first game is a port of the Playdate SDK sample of &lt;a href=\&quot;https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life\&quot; target=\&quot;_blank\&quot;&gt;Conway‚Äôs Game of Life&lt;/a&gt; into Swift:&lt;/p&gt;&lt;p&gt;    &lt;img src=\&quot;/assets/images/2024-03-12-byte-sized-swift-tiny-games-playdate/playdate-simulator-still-life.png\&quot; alt=\&quot;A screenshot of the Playdate Simulator running Conway‚Äôs Game of Life.\&quot;&gt;&lt;/p&gt;&lt;p&gt;This game is one Swift file that builds directly against the Playdate C API and does not require dynamic memory allocation. The packaged game clocks in at 788 bytes, slightly smaller than the C example, which is 904 bytes.&lt;/p&gt;&lt;pre&gt;&lt;code class=\&quot;language-shell\&quot;&gt;$ wc -c &amp;lt; $REPO_ROOT/Examples/Life/Life.pdx/pdex.bin\n     788\n\n$ wc -c &amp;lt; $HOME/Developer/PlaydateSDK/C_API/Examples/GameOfLife.pdx/pdex.bin\n     904\n&lt;/code&gt;&lt;/pre&gt;&lt;blockquote class=\&quot;note\&quot;&gt;&lt;p&gt;Note: Both versions could likely be made smaller, but I did not try to optimize code size.&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;The second game is a paddle-and-ball style game named ‚ÄúSwift Break.‚Äù&lt;/p&gt;&lt;p&gt;    &lt;img src=\&quot;/assets/images/2024-03-12-byte-sized-swift-tiny-games-playdate/playdate-simulator-still-swiftbreak.png\&quot; alt=\&quot;A screenshot of the Playdate Simulator with the Swift Break splash screen.\&quot;&gt;&lt;/p&gt;&lt;p&gt;Swift Break uses the same high-level language features you‚Äôd find in desktop and server applications, such as &lt;a href=\&quot;https://docs.swift.org/swift-book/documentation/the-swift-programming-language/enumerations/#Associated-Values\&quot; target=\&quot;_blank\&quot;&gt;enums with associated values&lt;/a&gt;, &lt;a href=\&quot;https://docs.swift.org/swift-book/documentation/the-swift-programming-language/generics\&quot; target=\&quot;_blank\&quot;&gt;generic types and functions&lt;/a&gt;, and &lt;a href=\&quot;https://docs.swift.org/swift-book/documentation/the-swift-programming-language/memorysafety\&quot; target=\&quot;_blank\&quot;&gt;automatic memory management&lt;/a&gt; to simplify game development while retaining C-level performance.&lt;/p&gt;&lt;p&gt;For example, here‚Äôs the core game logic for handling ball bounces:&lt;/p&gt;&lt;pre&gt;&lt;code class=\&quot;language-swift\&quot;&gt;sprite.moveWithCollisions(goalX: newX, goalY: newY) { _, _, collisions in\n  for collision in collisions {\n    let otherSprite = Sprite(borrowing: collision.other)\n\n    // If we hit a visible brick, remove it.\n    if otherSprite.tag == .brick, otherSprite.isVisible {\n      otherSprite.removeSprite()\n      activeGame.bricksRemaining -= 1\n    }\n\n    var normal = Vector(collision.normal)\n\n    if otherSprite.tag == .paddle {\n      // Compute deflection angle (radians) for the normal in domain\n      // -pi/6 to pi/6.\n      let placement = placement(of: collision, along: otherSprite)\n      let deflectionAngle = placement * (.pi / 6)\n      normal.rotate(by: deflectionAngle)\n    }\n\n    activeGame.ballVelocity.reflect(along: normal)\n  }\n}\n&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;It calls a &lt;code&gt;moveWithCollisions&lt;/code&gt; method to move the ball, iterating through a collection of objects the ball bounced off of while moving.&lt;/p&gt;&lt;p&gt;Swift Break features a splash screen, a pause menu, paddle-location-based bounce physics, infinite levels, a game over screen, and allows you to control the paddle with either the D-Pad or the Crank!&lt;/p&gt;&lt;h2 id=\&quot;try-it-out\&quot;&gt;Try it Out&lt;/h2&gt;&lt;p&gt;If you‚Äôre eager to use Swift on your Playdate, the &lt;a href=\&quot;https://github.com/apple/swift-playdate-examples\&quot; target=\&quot;_blank\&quot;&gt;swift-playdate-examples&lt;/a&gt; repository has you covered. It contains the above ready-to-use examples that demonstrate how to build Swift games for the Playdate, both for the simulator and the hardware.&lt;/p&gt;&lt;p&gt;Additionally, the repository includes detailed documentation to guide you through the setup process. Whether you‚Äôre a seasoned developer or just starting, you‚Äôll find the necessary resources to bring your ideas to life.&lt;/p&gt;&lt;p&gt;But if you‚Äôre up for a deep dive into the technical details of what it takes to bring Swift to a new platform, read on!&lt;/p&gt;&lt;h2 id=\&quot;deep-dive-bringing-swift-to-the-playdate\&quot;&gt;Deep Dive: Bringing Swift to the Playdate&lt;/h2&gt;&lt;p&gt;Bringing up a new platform is always fraught with challenges and infuriating bugs. Everything is broken with numerous false starts, until you clear the last bug, and then it all comes together. Getting Swift games running on the Playdate was no different.&lt;/p&gt;&lt;p&gt;My general approach was to leverage Swift‚Äôs interoperability to build on top of the Playdate C SDK. The good news is that the Swift toolchain already had all the features I needed to get this working. I just had to figure out how to put them together. Here‚Äôs an overview of the path I took:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Building object files for the Playdate Simulator&lt;/li&gt;&lt;li&gt;Importing the Playdate C API&lt;/li&gt;&lt;li&gt;Running on the Simulator&lt;/li&gt;&lt;li&gt;Running on the Hardware&lt;/li&gt;&lt;li&gt;Improving the API with Swift&lt;/li&gt;&lt;li&gt;Completing Swift Break&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;Without further ado, let‚Äôs get started.&lt;/p&gt;&lt;h3 id=\&quot;building-object-files-for-the-playdate-simulator\&quot;&gt;Building object files for the Playdate Simulator&lt;/h3&gt;&lt;blockquote class=\&quot;note\&quot;&gt;&lt;p&gt;Note: The commands mentioned below were run with a Swift nightly toolchain installed and have the &lt;code&gt;TOOLCHAINS&lt;/code&gt; environment variable set to the name of the toolchain.&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;My first step was compiling an object file for the Playdate Simulator. The simulator works by dynamically loading host libraries, so I needed to build the object files for the host‚Äôs platform and architecture (the so-called &lt;em&gt;triple&lt;/em&gt; in compiler-speak), which &lt;code&gt;swiftc&lt;/code&gt; does by default. The only additional flags I needed were for enabling embedded Swift and code optimizations.&lt;/p&gt;&lt;pre&gt;&lt;code class=\&quot;language-shell\&quot;&gt;$ cat test.swift\nlet value = 1\n\n$ mkdir build\n\n$ swiftc -c test.swift -o build/test.o \\\n    -Osize -wmo -enable-experimental-feature Embedded\n\n$ file build/test.o\ntest.o: Mach-O 64-bit object arm64\n&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=\&quot;importing-the-playdate-c-api\&quot;&gt;Importing the Playdate C API&lt;/h3&gt;&lt;p&gt;The next step was compiling against the Playdate C API from Swift. This was straightforward due to the structure of the Playdate C header files and Swift‚Äôs native support for interoperating with C.&lt;/p&gt;&lt;p&gt;I started by locating the Playdate C header files:&lt;/p&gt;&lt;pre&gt;&lt;code class=\&quot;language-shell\&quot;&gt;$ ls $HOME/Developer/PlaydateSDK/C_API/\nExamples     buildsupport pd_api       pd_api.h\n\n$ ls $HOME/Developer/PlaydateSDK/C_API/pd_api\npd_api_display.h     pd_api_gfx.h         pd_api_lua.h         pd_api_sound.h       pd_api_sys.h\npd_api_file.h        pd_api_json.h        pd_api_scoreboards.h pd_api_sprite.h\n&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;And used an ‚Äúinclude search path‚Äù (&lt;code&gt;-I&lt;/code&gt;) to tell the Swift compiler‚Äôs C interoperability feature where to find them. I additionally needed to pass a ‚Äúdefine‚Äù (&lt;code&gt;-D&lt;/code&gt;) to tell the compiler how to parse the header files:&lt;/p&gt;&lt;pre&gt;&lt;code class=\&quot;language-shell\&quot;&gt;$ swiftc ... -Xcc -I -Xcc $HOME/Developer/PlaydateSDK/C_API/ -Xcc -DTARGET_EXTENSION\n&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Next, I created a &lt;a href=\&quot;https://clang.llvm.org/docs/Modules.html#module-maps\&quot; target=\&quot;_blank\&quot;&gt;module map file&lt;/a&gt; to wrap the headers into an importable module from Swift:&lt;/p&gt;&lt;pre&gt;&lt;code class=\&quot;language-shell\&quot;&gt;$ cat $HOME/Developer/PlaydateSDK/C_API/module.modulemap\nmodule CPlaydate [system] {\n  umbrella header \&quot;pd_api.h\&quot;\n  export *\n}\n&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;And used an ‚Äúimport search path‚Äù (&lt;code&gt;-I&lt;/code&gt;) to tell the Swift compiler where to find the CPlaydate module:&lt;/p&gt;&lt;pre&gt;&lt;code class=\&quot;language-shell\&quot;&gt;$ swiftc ... -I $HOME/Developer/PlaydateSDK/C_API/\n&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Lastly, I made a minimal ‚Äúlibrary‚Äù using the Playdate C API from Swift and compiled using the flags above:&lt;/p&gt;&lt;pre&gt;&lt;code class=\&quot;language-shell\&quot;&gt;$ cat test.swift\nimport CPlaydate\nlet pd: UnsafePointer&amp;lt;PlaydateAPI&amp;gt;? = nil\n\n$ mkdir build\n\n$ swiftc \\\n    -c test.swift \\\n    -o build/test.o \\\n    -Osize -wmo -enable-experimental-feature Embedded \\\n    -Xcc -I -Xcc $HOME/Developer/PlaydateSDK/C_API/ \\\n    -Xcc -DTARGET_EXTENSION \\\n    -I $HOME/Developer/PlaydateSDK/C_API/\n\n$ file build/test.o\ntest.o: Mach-O 64-bit object arm64\n&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=\&quot;running-on-the-simulator\&quot;&gt;Running on the Simulator&lt;/h3&gt;&lt;p&gt;Once I was able to use the Playdate C API from Swift, I ported the Conway‚Äôs Game of Life example included in the Playdate SDK to Swift, referencing &lt;a href=\&quot;https://sdk.play.date/2.2.0/Inside%20Playdate%20with%20C.html\&quot; target=\&quot;_blank\&quot;&gt;Inside Playdate with C&lt;/a&gt; frequently to familiarize myself with the API.&lt;/p&gt;&lt;p&gt;The C implementation of Conway‚Äôs strictly operates on Playdate OS-vended frame buffers and uses the display as game state, removing the need for separate data structures and dynamic allocations. As a result, the porting process was very mechanical because the bit manipulation and pointer operations in the C example have direct Swift analogs:&lt;/p&gt;&lt;pre&gt;&lt;code class=\&quot;language-c\&quot;&gt;static inline int val(uint8_t* row, int x) {\n    return 1 - ((row[x/8] &amp;gt;&amp;gt; (7 - (x%8))) &amp; 1);\n}\n\nstatic inline int ison(uint8_t* row, int x) {\n    return !(row[x/8] &amp; (0x80 &amp;gt;&amp;gt; (x%8)));\n}\n&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code class=\&quot;language-swift\&quot;&gt;struct Row {\n  var buffer: UnsafeMutablePointer&amp;lt;UInt8&amp;gt;\n\n  func value(at column: Int32) -&amp;gt; UInt8 {\n    isOn(at: column) ? 1 : 0\n  }\n\n  func isOn(at column: Int32) -&amp;gt; Bool {\n    let byte = buffer[Int(column / 8)]\n    let bitPosition = 0x80 &amp;gt;&amp;gt; (column % 8)\n    return (byte &amp; bitPosition) == 0\n  }\n}\n&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;I built the source into a dynamic library and used &lt;code&gt;pdc&lt;/code&gt; (the Playdate compiler) to wrap the final &lt;code&gt;dylib&lt;/code&gt; into a &lt;code&gt;pdx&lt;/code&gt; (Playdate executable).&lt;/p&gt;&lt;pre&gt;&lt;code class=\&quot;language-shell\&quot;&gt;$ swiftc \\\n    -emit-library test.swift \\\n    -o build/pdex.dylib \\\n    ...\n\n$ file build/pdex.dylib\npdex.dylib: Mach-O 64-bit dynamically linked shared library arm64\n\n$ $HOME/Developer/PlaydateSDK/bin/pdc build Test\n\n$ ls Test.pdx\npdex.dylib pdxinfo\n&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;I opened my game file &lt;code&gt;Test.pdx&lt;/code&gt; using the Playdate simulator and as you might expect, it worked on the first try ‚Ä¶ just kidding, it crashed!&lt;/p&gt;&lt;p&gt;After some debugging, I realized the &lt;code&gt;Makefile&lt;/code&gt; used to compile the C example included an additional file &lt;code&gt;setup.c&lt;/code&gt; from the SDK containing the symbol &lt;code&gt;_eventHandlerShim&lt;/code&gt; needed to bootstrap the game. If this symbol is not present in the binary, the Simulator falls back to bootstrapping the game using the symbol &lt;code&gt;_eventHandler&lt;/code&gt; which my binary did contain, but meant my game skipped an important setup step.&lt;/p&gt;&lt;p&gt;So, I compiled &lt;code&gt;setup.c&lt;/code&gt; into an object file using &lt;code&gt;clang&lt;/code&gt;, linked it into my dynamic library, re-ran, and voila! I had Conway‚Äôs Game of Life written in Swift running on the Playdate Simulator.&lt;/p&gt;&lt;h3 id=\&quot;running-on-the-hardware\&quot;&gt;Running on the Hardware&lt;/h3&gt;&lt;p&gt;After successfully running on the simulator, I wanted to run the game on real hardware. A colleague graciously allowed me to borrow their Playdate and I began hacking away.&lt;/p&gt;&lt;p&gt;I started by matching the triple used by the C examples for the device and seeing what happened.&lt;/p&gt;&lt;pre&gt;&lt;code class=\&quot;language-shell\&quot;&gt;$ swiftc ... -target armv7em-none-none-eabi\n&amp;lt;module-includes&amp;gt;:1:10: note: in file included from &amp;lt;module-includes&amp;gt;:1:\n#include \&quot;pd_api.h\&quot;\n         ^\n$HOME/Developer/PlaydateSDK/C_API/pd_api.h:13:10: error: \&#39;stdlib.h\&#39; file not found\n#include &amp;lt;stdlib.h&amp;gt;\n         ^\n&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;These errors did not previously occur because I was targeting the host machine and used the host headers for the C standard library. I considered using the same host headers for the target device, but didn‚Äôt want to debug platform incompatibilities. Little did I know, I would have to do this regardless.&lt;/p&gt;&lt;p&gt;Instead, I decided to follow the route used by the C example programs which leverage the libc headers from a &lt;code&gt;gcc&lt;/code&gt; toolchain installed with the Playdate SDK. I copied the include paths used by the C examples and re-ran the compile.&lt;/p&gt;&lt;pre&gt;&lt;code class=\&quot;language-shell\&quot;&gt;$ mkdir build\n\n$ GCC_LIB=/usr/local/playdate/gcc-arm-none-eabi-9-2019-q4-major/lib\n\n$ swiftc \\\n    -c test.swift \\\n    -o build/test.o \\\n    -target armv7em-none-none-eabi \\\n    -Osize -wmo -enable-experimental-feature Embedded \\\n    -I $HOME/Developer/PlaydateSDK/C_API/ \\\n    -Xcc -DTARGET_EXTENSION \\\n    -Xcc -I -Xcc $HOME/Developer/PlaydateSDK/C_API/ \\\n    -Xcc -I -Xcc $GCC_LIB/gcc/arm-none-eabi/9.2.1/include \\\n    -Xcc -I -Xcc $GCC_LIB/gcc/arm-none-eabi/9.2.1/include-fixed \\\n    -Xcc -I -Xcc $GCC_LIB/gcc/arm-none-eabi/9.2.1/../../../../arm-none-eabi/include\n\n$ file build/test.o\ntest.o: ELF 32-bit LSB relocatable, ARM, EABI5 version 1 (SYSV), not stripped\n&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The compile succeeded and I had an object file for the real hardware. I went through similar steps to link and package the object file into a &lt;code&gt;pdx&lt;/code&gt;, using &lt;code&gt;clang&lt;/code&gt; as the linker driver.&lt;/p&gt;&lt;p&gt;I deployed the game onto a Playdate, and ‚Ä¶ it crashed.&lt;/p&gt;&lt;p&gt;For some reason, when the frame-update function pointer was called, the game would crash! Debugging this issue was confusing at first, but due to past experience deploying Swift onto a Cortex M7, I realized I likely had a calling convention mismatch. I added a compiler flag &lt;code&gt;-Xfrontend -experimental-platform-c-calling-convention=arm_aapcs_vfp&lt;/code&gt; to try to match the calling convention used by the Playdate OS.&lt;/p&gt;&lt;p&gt;Once again, I deployed my game to the Playdate and ‚Ä¶ it actually worked! You can see the game in action below:&lt;/p&gt;&lt;video title=\&quot;A video of Conway\&#39;s Game of Life running on Playdate hardware mirrored to a Mac.\&quot; autoplay loop muted style=\&quot;width: 100%; border-radius: 15px;\&quot;&gt;\n  &lt;source src=\&quot;{{site.url}}/assets/images/2024-03-12-byte-sized-swift-tiny-games-playdate/playdate-mirror-video-life.mp4\&quot; type=\&quot;video/mp4\&quot;&gt;\n&lt;/video&gt;\n&lt;p&gt;I then integrated my manual compilation steps into the Makefiles found in the Playdate SDK, going through a number of options before landing on the final solution found in &lt;code&gt;swift-playdate-examples&lt;/code&gt;. The result of this effort was a single &lt;code&gt;make&lt;/code&gt; command to build a &lt;code&gt;pdx&lt;/code&gt; compatible with both the simulator and hardware!&lt;/p&gt;&lt;h3 id=\&quot;improving-the-api-with-swift\&quot;&gt;Improving the API with Swift&lt;/h3&gt;&lt;p&gt;After porting Conway‚Äôs Game of Life, I began a more ambitious project: a paddle-and-ball style game named Swift Break. However, I quickly encountered friction using the raw Playdate C API directly in Swift. In typical programming fashion, I took a detour to work on the API‚Äôs ergonomics instead of the game! At this point, I had also piqued the interest of some colleagues who contributed further improvements.&lt;/p&gt;&lt;p&gt;One hurdle was the naming conventions of the imported API. In C, enum cases are often prefixed with their type‚Äôs name to prevent programmers from inadvertently mixing unrelated enum instances and case constants. However, in Swift, such prefixes are unnecessary as the compiler type-checks comparisons to ensure the correct cases are used.&lt;/p&gt;&lt;p&gt;Fortunately, Swift already provides tools for addressing this precise issue, known as &lt;a href=\&quot;https://clang.llvm.org/docs/APINotes.html\&quot; target=\&quot;_blank\&quot;&gt;API notes&lt;/a&gt;. I added an API notes file to the Playdate SDK and renamed enum cases with more idiomatic Swift names:&lt;/p&gt;&lt;pre&gt;&lt;code class=\&quot;language-swift\&quot;&gt;// Before\nif event == kEventPause { ... }\n\n// After\nif event == .pause { ... }\n&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;A bigger issue, however, was the lack of nullability annotations in the C API. This meant the generated code had redundant null checks everywhere, bloating code size and hurting performance. While I usually would have used API notes to add the missing annotations, this was not possible. The C API uses structs with function pointers as a ‚Äúvtable‚Äù, and unfortunately, these are not currently modifiable with API notes. Due to this incompatibility, I had to adopt a suboptimal solution: pervasively using &lt;code&gt;Optional.unsafelyUnwrapped&lt;/code&gt; throughout the Swift code.&lt;/p&gt;&lt;p&gt;Although this approach eliminated the null checks, it dramatically hurt readability:&lt;/p&gt;&lt;pre&gt;&lt;code class=\&quot;language-swift\&quot;&gt;// C API in Swift with redundant null checks\nlet spritePointer = playdate_api.pointee.sprite.pointee.newSprite()\n\n// C API in Swift without redundant null checks\nlet spritePointer = playdate_api.unsafelyUnwrapped.pointee.sprite.unsafelyUnwrapped.pointee.newSprite.unsafelyUnwrapped()\n&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;To address the readability issues, I created a thin Swift overlay on top of the C API. I wrapped function pointer accesses into static and instance methods on Swift types and converted function get/set pairs to Swift properties. Creating a sprite became much more intuitive and introduced zero overhead on top of the equivalent imported C calls.&lt;/p&gt;&lt;pre&gt;&lt;code class=\&quot;language-swift\&quot;&gt;var sprite = Sprite(bitmapPath: \&quot;background.png\&quot;)\nsprite.collisionsEnabled = false\nsprite.zIndex = 0\nsprite.addSprite()\n&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Colleagues further improved the overlay by abstracting Playdate APIs requiring manual memory management to be automatically handled. An excellent example is the C API‚Äôs &lt;a href=\&quot;https://sdk.play.date/2.2.0/Inside%20Playdate%20with%20C.html#f-sprite.moveWithCollisions\&quot; target=\&quot;_blank\&quot;&gt;&lt;code&gt;moveWithCollisions&lt;/code&gt;&lt;/a&gt; function, which returns a buffer of &lt;code&gt;SpriteCollisionInfo&lt;/code&gt; structs that must be freed by the caller. Using the overlay allowed us to avoid manually deallocating the buffer and made the API easier to use:&lt;/p&gt;&lt;pre&gt;&lt;code class=\&quot;language-swift\&quot;&gt;// moveWithCollisions without the overlay\nvar count: Int32 = 0\nvar actualX: Int32 = 0\nvar actualY: Int32 = 0\nlet collisionsStartAddress = playdate_api.pointee.sprite.pointee.moveWithCollisions(sprite, 10, 10, &amp;actualX, &amp;actualY, &amp;count)\nlet collisions = UnsafeBufferPointer(start: collisionsStartAddress, count: count)\ndefer { collisions.deallocate() }\nfor collision in collisions { ... }\n\n// moveWithCollisions with the overlay\nsprite.moveWithCollisions(goalX: 10, goalY: 10) { actualX, actualY, collisions in\n    for collision in collisions { ... }\n}\n&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;These improvements dramatically streamlined writing code for the Playdate. Additionally, as Swift‚Äôs support for ownership and non-copyable types improves, I anticipate even more ergonomic representations of the C APIs without language overhead.&lt;/p&gt;&lt;h3 id=\&quot;completing-swift-break\&quot;&gt;Completing Swift Break&lt;/h3&gt;&lt;p&gt;Equipped with a refined Swift Playdate API, I returned to developing Swift Break.&lt;/p&gt;&lt;p&gt;I nailed down the basics pretty quickly, but couldn‚Äôt resist adding extra features just for the fun of it. One of the highlights was implementing basic logic to deflect ball bounces based on the location where the ball and paddle collide.&lt;/p&gt;&lt;p&gt;This feature required calculating a normal vector relative to a hypothetical curve representing a rounded paddle and then reflecting the ball‚Äôs velocity about the normal. Here‚Äôs a visualization of the intended behavior:&lt;/p&gt;&lt;video title=\&quot;A Desmos geometric animation of Swift Break ball bouncing logic.\&quot; autoplay loop muted style=\&quot;width: 100%; border-radius: 15px;\&quot;&gt;\n  &lt;source src=\&quot;{{site.url}}/assets/images/2024-03-12-byte-sized-swift-tiny-games-playdate/desmos-ball-bounce.mp4\&quot; type=\&quot;video/mp4\&quot;&gt;\n&lt;/video&gt;\n&lt;blockquote class=\&quot;note\&quot;&gt;&lt;p&gt;Note: Making the animation for this post ironically helped me root cause a bug in the bouncing logic. Under some combinations of entry angle and normal angle, the current design can cause the ball to bounce &lt;em&gt;down&lt;/em&gt; into the paddle instead of up.&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;To turn the math into an algorithm, I had to perform the following steps:&lt;/p&gt;&lt;ol&gt;&lt;li&gt;Check if the object the ball collided with is the paddle&lt;/li&gt;&lt;li&gt;Compute the location of the collision along the paddle from -1 to +1&lt;/li&gt;&lt;li&gt;Map the location into a deflection angle from from -œÄ/6 to +œÄ/6&lt;/li&gt;&lt;li&gt;Rotate the collision normal vector by the deflection angle&lt;/li&gt;&lt;li&gt;Reflect the ball‚Äôs velocity along the rotated normal&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;I then directly translated this algorithm into code inside the ball collision callback:&lt;/p&gt;&lt;pre&gt;&lt;code class=\&quot;language-swift\&quot;&gt;if otherSprite.tag == .paddle {                                // 1\n  let placement = placement(of: collision, along: otherSprite) // 2\n  let deflectionAngle = placement * (.pi / 6)                  // 3\n  normal.rotate(by: deflectionAngle)                           // 4\n}\nballVelocity.reflect(along: normal)                            // 5\n&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=\&quot;running-on-the-hardware-again\&quot;&gt;Running on the Hardware (Again!)&lt;/h3&gt;&lt;p&gt;Throughout the development of ‚ÄúSwift Break,‚Äù I regularly deployed the game to the Playdate Simulator. However, the real challenge emerged when I decided to run the game on actual Playdate hardware. As usual, I loaded the game, and ‚Ä¶ yet again, it crashed, but this time a lot of things were going wrong.&lt;/p&gt;&lt;p&gt;To cut a long debugging story short, I found that the &lt;code&gt;-Xfrontend&lt;/code&gt; flag mentioned earlier did not entirely resolve the calling convention issues. To address this, I needed to configure the compiler to match the CPU and floating-point ABI of the microcontroller in the Playdate. This aspect was overlooked when I was porting Conway‚Äôs Game of Life since I happened to both not pass structs by value and didn‚Äôt use floating-point operations.&lt;/p&gt;&lt;p&gt;The final and most confusing crash arose from a specific Playdate C API call returning an enum from the Playdate OS. After a thorough debugging process, e.g. using &lt;code&gt;printf&lt;/code&gt; everywhere, I uncovered a discrepancy in the memory layout of the enum between the system built with &lt;code&gt;gcc&lt;/code&gt; and the game built with &lt;code&gt;swiftc&lt;/code&gt;. With further research I found the difference stemmed from &lt;code&gt;gcc&lt;/code&gt; defaulting to &lt;code&gt;-fshort-enums&lt;/code&gt; while &lt;code&gt;swiftc&lt;/code&gt; via &lt;code&gt;clang&lt;/code&gt; used &lt;code&gt;-fno-short-enums&lt;/code&gt; for the &lt;code&gt;armv7em-none-none-eabi&lt;/code&gt; triple.&lt;/p&gt;&lt;p&gt;I collected these new and removed flags into the following compile command:&lt;/p&gt;&lt;pre&gt;&lt;code class=\&quot;language-shell\&quot;&gt;$ swiftc \\\n    -c test.swift \\\n    -o build/test.o \\\n    -target armv7em-none-none-eabi \\\n    -Osize -wmo -enable-experimental-feature Embedded \\\n    -I $HOME/Developer/PlaydateSDK/C_API \\\n    -Xcc -D__FPU_USED=1 \\\n    -Xcc -DTARGET_EXTENSION \\\n    -Xcc -falign-functions=16 \\\n    -Xcc -fshort-enums \\\n    -Xcc -mcpu=cortex-m7 \\\n    -Xcc -mfloat-abi=hard \\\n    -Xcc -mfpu=fpv5-sp-d16 \\\n    -Xcc -mthumb \\\n    -Xcc -I -Xcc $HOME/Developer/PlaydateSDK/C_API/ \\\n    -Xcc -I -Xcc $GCC_LIB/gcc/arm-none-eabi/9.2.1/include \\\n    -Xcc -I -Xcc $GCC_LIB/gcc/arm-none-eabi/9.2.1/include-fixed \\\n    -Xcc -I -Xcc $GCC_LIB/gcc/arm-none-eabi/9.2.1/../../../../arm-none-eabi/include \\\n    -Xfrontend -disable-stack-protector \\\n    -Xfrontend -experimental-platform-c-calling-convention=arm_aapcs_vfp \\\n    -Xfrontend -function-sections\n&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;With these adjustments, I attempted once more, and &lt;em&gt;finally&lt;/em&gt; ‚ÄúSwift Break‚Äù successfully ran on the Playdate hardware! I‚Äôve included a brief video showcasing the game below:&lt;/p&gt;&lt;video title=\&quot;A screencapture of Swift Break running on Playdate hardware mirrored to a Mac.\&quot; autoplay loop muted style=\&quot;width: 100%; border-radius: 15px;\&quot;&gt;\n  &lt;source src=\&quot;{{site.url}}/assets/images/2024-03-12-byte-sized-swift-tiny-games-playdate/playdate-mirror-video-swiftbreak.mp4\&quot; type=\&quot;video/mp4\&quot;&gt;\n&lt;/video&gt;\n&lt;h2 id=\&quot;wrapping-up\&quot;&gt;Wrapping Up&lt;/h2&gt;&lt;p&gt;Thanks for diving into the bring-up journey with me. From refining the Swift Playdate API to tackling issues involving calling conventions, CPU configurations, and memory layout disparities, there was no shortage of challenges.&lt;/p&gt;&lt;p&gt;However, with the issues now resolved, creating Playdate games in Swift is a streamlined process. Just run &lt;code&gt;make&lt;/code&gt; and enjoy a development experience with Swift that is both expressive &lt;em&gt;and&lt;/em&gt; performant.&lt;/p&gt;&lt;p&gt;You can find all the code examples mentioned in this post in the &lt;a href=\&quot;https://github.com/apple/swift-playdate-examples\&quot; target=\&quot;_blank\&quot;&gt;swift-playdate-examples&lt;/a&gt; repository with accompanying ‚ÄúGetting Started‚Äù documentation.&lt;/p&gt;&lt;p&gt;I hope this post encourages you to explore the possibilities of using Swift in unconventional environments. Feel free to reach out with your experiences, questions, or game ideas on the &lt;a href=\&quot;https://forums.swift.org/t/byte-sized-swift-building-tiny-games-for-the-playdate/70615\&quot; target=\&quot;_blank\&quot;&gt;Swift Forums&lt;/a&gt;!&lt;/p&gt;&lt;p&gt;Happy coding! üéÆ&lt;/p&gt;&quot;, &quot;title&quot;: &quot;Byte-sized Swift: Building Tiny Games for the Playdate&quot;, &quot;js&quot;: [], &quot;toc&quot;: [ToucanSDK.ToCNode(level: 2, text: &quot;Why Swift?&quot;, fragment: &quot;why-swift&quot;, children: [ToucanSDK.ToCNode(level: 3, text: &quot;Playdate by Panic&quot;, fragment: &quot;playdate-by-panic&quot;, children: []), ToucanSDK.ToCNode(level: 3, text: &quot;The Embedded Language Mode&quot;, fragment: &quot;the-embedded-language-mode&quot;, children: [])]), ToucanSDK.ToCNode(level: 2, text: &quot;The Games&quot;, fragment: &quot;the-games&quot;, children: []), ToucanSDK.ToCNode(level: 2, text: &quot;Try it Out&quot;, fragment: &quot;try-it-out&quot;, children: []), ToucanSDK.ToCNode(level: 2, text: &quot;Deep Dive: Bringing Swift to the Playdate&quot;, fragment: &quot;deep-dive-bringing-swift-to-the-playdate&quot;, children: [ToucanSDK.ToCNode(level: 3, text: &quot;Building object files for the Playdate Simulator&quot;, fragment: &quot;building-object-files-for-the-playdate-simulator&quot;, children: []), ToucanSDK.ToCNode(level: 3, text: &quot;Importing the Playdate C API&quot;, fragment: &quot;importing-the-playdate-c-api&quot;, children: []), ToucanSDK.ToCNode(level: 3, text: &quot;Running on the Simulator&quot;, fragment: &quot;running-on-the-simulator&quot;, children: []), ToucanSDK.ToCNode(level: 3, text: &quot;Running on the Hardware&quot;, fragment: &quot;running-on-the-hardware&quot;, children: []), ToucanSDK.ToCNode(level: 3, text: &quot;Improving the API with Swift&quot;, fragment: &quot;improving-the-api-with-swift&quot;, children: []), ToucanSDK.ToCNode(level: 3, text: &quot;Completing Swift Break&quot;, fragment: &quot;completing-swift-break&quot;, children: []), ToucanSDK.ToCNode(level: 3, text: &quot;Running on the Hardware (Again!)&quot;, fragment: &quot;running-on-the-hardware-again&quot;, children: [])]), ToucanSDK.ToCNode(level: 2, text: &quot;Wrapping Up&quot;, fragment: &quot;wrapping-up&quot;, children: [])], &quot;slug&quot;: &quot;articles/2024-03-12-byte-sized-swift-tiny-games-playdate&quot;, &quot;description&quot;: &quot;FIXME: Write this..&quot;, &quot;imageUrl&quot;: false, &quot;canonical&quot;: &quot;http://localhost:3000/articles/2024-03-12-byte-sized-swift-tiny-games-playdate/&quot;]], &quot;authors&quot;: [&quot;tibor-bodecs&quot;], &quot;lastModification&quot;: ToucanSDK.PageBundle.DateValue(html: &quot;March 08, 2025&quot;, rss: &quot;Sat, 08 Mar 2025 19:53:38 +0000&quot;, sitemap: &quot;2025-03-08&quot;), &quot;slug&quot;: &quot;articles/test-post-2&quot;, &quot;title&quot;: &quot;Beginner\&#39;s guide to Swift package manager command plugins&quot;, &quot;js&quot;: [], &quot;publication&quot;: ToucanSDK.PageBundle.DateValue(html: &quot;May 16, 2022&quot;, rss: &quot;Mon, 16 May 2022 16:20:00 +0000&quot;, sitemap: &quot;2022-05-16&quot;), &quot;contents&quot;: &quot;&lt;p&gt;Lorem ipsum dolor sit amet, consectetur adipiscing elit. Sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.&lt;/p&gt;&lt;h2 id=\&quot;heading-2\&quot;&gt;Heading 2&lt;/h2&gt;&lt;p&gt;Lorem ipsum dolor sit amet, consectetur adipiscing elit.  Aliquam erat volutpat.  Nulla quis ligula ipsum.  Suspendisse cursus faucibus est, ut ultricies ante euismod vitae.  Donec sit amet risus a risus aliquet vestibulum.  Maecenas sit amet orci eget eros faucibus tincidunt.  Duis leo.  Sed fringilla mauris sit amet nibh.  Donec sodales sagittis magna.  Sed consequat, leo eget bibendum sodales, augue velit cursus nunc, quis euismod sem libero ut magna.  Nam adipiscing.  Suspendisse potenti.&lt;/p&gt;&lt;h3 id=\&quot;heading-3\&quot;&gt;Heading 3&lt;/h3&gt;&lt;p&gt;Lorem ipsum dolor sit amet, consectetur adipiscing elit. Integer nec odio. Praesent libero. Sed cursus ante ac ante. Duis sagittis ipsum. Praesent mauris. Fusce accumsan massa. Quisque vitae magna.  Aenean tellus metus, bibendum sit amet, suscipit id, rutrum ac, nisi.  Nulla quis diam.  Nulla adipiscing.  In non turpis.  Curabitur purus.  Phasellus magna.  Vestibulum ante ipsum primis in faucibus orci luctus et ultrices posuere cubilia Curae;  Nulla tempor.  Mauris blandit aliquet elit.  Mauris nibh felis, adipiscing rhoncus, ultricies eu, bibendum non, nibh.  Suspendisse ultrices gravida.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Bold Text&lt;/strong&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;List item 1&lt;/li&gt;&lt;li&gt;List item 2&lt;/li&gt;&lt;li&gt;List item 3&lt;/li&gt;&lt;/ul&gt;&lt;ol&gt;&lt;li&gt;Numbered list item 1&lt;/li&gt;&lt;li&gt;Numbered list item 2&lt;/li&gt;&lt;li&gt;Numbered list item 3&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;a href=\&quot;https://www.example.com\&quot; target=\&quot;_blank\&quot;&gt;Link to Example&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;code&gt;Inline code&lt;/code&gt;&lt;/p&gt;&quot;, &quot;css&quot;: [], &quot;tags&quot;: [&quot;swift-package-manager&quot;], &quot;canonical&quot;: &quot;http://localhost:3000/articles/test-post-2/&quot;, &quot;permalink&quot;: &quot;http://localhost:3000/articles/test-post-2/&quot;, &quot;readingTime&quot;: 1, &quot;description&quot;: &quot;Learn how to create command plugins for the Swift Package Manager to execute custom actions using SPM and other tools.&quot;]</h4>
                            
                            <div class="card">
                                <div class="meta">
                                    <time datetime="May 16, 2022">May 16, 2022</time>
                                     &middot; <span class="reading-time">1 min read</span>
                                </div>
                                
                                <h2 class="title"><a href="http://localhost:3000/articles/test-post-2/" target="">Beginner&#39;s guide to Swift package manager command plugins</a></h2>
                                <p>Learn how to create command plugins for the Swift Package Manager to execute custom actions using SPM and other tools.</p>
                            
                                <div class="spacer"></div>
                            
                                <div class="tag-list">
                                    <a href="http://localhost:3000/articles/test-post-2/"><small>Beginner&#39;s guide to Swift package manager command plugins</small></a>
                                </div>
                            </div>
                        </div>
                    
                        <br>
                        <a href="/articles/page/1" class="cta">Browse all articles</a>
                    </div>
                    

                </main>
            </div>
        </div>
        <div class="content-footer">
            <footer>
                <p class="small">rauhul.me &copy; 2025</p>
                <a rel="me" href="https://hachyderm.io/@rauhul"></a>
            </footer>
        </div>
    </div>

    
</body>
</html>
